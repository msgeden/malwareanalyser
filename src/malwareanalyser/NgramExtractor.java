/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.util.*;
import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.time.StopWatch;

/**
 *
 * @author msgeden
 */
public class NgramExtractor {

	public static HashMap<String, Short[]> constructNgramsPerApp(
			HashMap<String, Short[]> cumulativeNgrams, String appPath,
			String extension, boolean isTestData, File reportFile) {

		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			// Collect all files under the path of given app
			Collection<File> files = FileHandler.findFiles(appPath,
					new String[] { extension });

			// This will keep the information whether given app owns ngrams
			HashSet<String> ngrams = new HashSet<String>();

			// Retrieve class type, its name and its integer array index from
			// file path
			boolean taxon = appPath.contains(File.separator
					+ Constants.CLASS_A_NAME + File.separator);
			String className = taxon ? Constants.CLASS_A_NAME
					: Constants.CLASS_B_NAME;
			int classFrequencyIndex = taxon ? 0 : 1;

			// Retrieve app name from file path
			String[] folders = appPath.split(File.separator);
			String appName = folders[folders.length - 1];
			// Number of files traversed
			int fileIterator = -1;

			// Performance monitor watch
			StopWatch watch = new StopWatch();
			watch.reset();
			watch.start();

			// Traverse app files to be analyzed
			for (File file : files) {
				fileIterator++;

				// Read files as byte array and convert them to hexadecimal
				// strings
				byte[] fileHex = FileHandler.readFileToByteArray(file
						.getAbsolutePath());
				for (int i = 0; i < fileHex.length - (ngramSize - 1); i++) {
					StringBuilder sb = new StringBuilder();
					for (int j = 0; j < ngramSize; j++) {
						// if (fileHex[i + j] != 0)
						sb.append(String.format("%02X", fileHex[i + j]));

					}
					String ngram = sb.toString();
					ngrams.add(ngram);
				}
			}
			// Merge app ngram set with cumulative ngram hashmap
			for (String ngram : ngrams) {
				if (cumulativeNgrams.containsKey(ngram)) {
					Short[] classFrequencies = cumulativeNgrams.get(ngram);
					classFrequencies[classFrequencyIndex] = (short) (classFrequencies[classFrequencyIndex] + 1);
					cumulativeNgrams.put(ngram, classFrequencies);
				} else {
					Short[] classFrequencies = new Short[] { 0, 0 };
					classFrequencies[classFrequencyIndex] = 1;
					cumulativeNgrams.put(ngram, classFrequencies);
				}
			}

			// These values are stored in ngrams hashmap not to iterate once
			// more during the information gain calculation
			if (cumulativeNgrams.containsKey(Constants.COUNT_OF_APPS_PER_CLASS)) {
				Short[] appCountsForClasses = cumulativeNgrams
						.get(Constants.COUNT_OF_APPS_PER_CLASS);
				appCountsForClasses[classFrequencyIndex] = (short) (appCountsForClasses[classFrequencyIndex] + 1);
				cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS,
						appCountsForClasses);
			} else {
				Short[] appCountsForClasses = new Short[] { 0, 0 };
				appCountsForClasses[classFrequencyIndex] = 1;
				cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS,
						appCountsForClasses);
			}

			// Print the number of unique ngrams, files are processed.
			// Print the number of unique ngrams, files are processed.
			FileUtils.write(reportFile, className + Constants.TAB_CHAR
					+ extension + Constants.TAB_CHAR + ngrams.size()
					+ Constants.TAB_CHAR + cumulativeNgrams.size()
					+ Constants.TAB_CHAR + (fileIterator + 1)
					+ Constants.TAB_CHAR + (double) watch.getTime() / 1000.0
					+ Constants.TAB_CHAR + appName + "\n", true);
			System.out.print(className + Constants.TAB_CHAR + extension
					+ Constants.TAB_CHAR + ngrams.size() + Constants.TAB_CHAR
					+ cumulativeNgrams.size() + Constants.TAB_CHAR
					+ (fileIterator + 1) + Constants.TAB_CHAR
					+ (double) watch.getTime() / 1000.0 + Constants.TAB_CHAR
					+ appName + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return cumulativeNgrams;
	}

	public static HashMap<String, Short[]> constructNgrams(String dataPath,
			String extension, boolean isTestData) {

		HashMap<String, Short[]> ngrams = new HashMap<String, Short[]>();
		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			String[] appPaths = appPathsOfGivenClass(dataPath, extension,
					isTestData);

			// Data class label for reports and input files
			String trainOrTestLabel = isTestData ? Constants.TEST_LABEL
					: Constants.TRAIN_LABEL;

			// Generate report file name
			String reportFilePath = (FileHandler
					.readConfigValue(Constants.REPORTS_PATH_CONFIG)
					+ trainOrTestLabel
					+ Constants.UNDERSCORE
					+ extension
					+ Constants.UNDERSCORE
					+ "ngram"
					+ Constants.UNDERSCORE
					+ ngramSize + Constants.UNDERSCORE + "report.tsv")
					.toLowerCase();

			File reportFile = new File(reportFilePath);
			FileUtils.deleteQuietly(reportFile);

			FileUtils.write(reportFile, "Class" + Constants.TAB_CHAR
					+ "Extension" + Constants.TAB_CHAR + "# of Ngrams"
					+ Constants.TAB_CHAR + "# of Total Ngrams"
					+ Constants.TAB_CHAR + "Number of Files"
					+ Constants.TAB_CHAR + "Time Elapsed" + Constants.TAB_CHAR
					+ "App Name" + Constants.TAB_CHAR + "\n", true);
			System.out.print("Number" + Constants.TAB_CHAR + "Class"
					+ Constants.TAB_CHAR + "Extension" + Constants.TAB_CHAR
					+ "# of Ngrams" + Constants.TAB_CHAR + "# of Total Ngrams"
					+ Constants.TAB_CHAR + "Number of Files"
					+ Constants.TAB_CHAR + "Time Elapsed" + Constants.TAB_CHAR
					+ "App Name" + Constants.TAB_CHAR + "\n");
			int count = 0;
			for (String appPath : appPaths) {
				System.out.print((++count) + Constants.TAB_CHAR);
				ngrams = constructNgramsPerApp(ngrams, appPath, extension,
						isTestData, reportFile);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngrams;
	}

	public static String extractDistinctiveNgramsByIG(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE + "distinctive_" + ngramSize + "-grams_by_ig.tsv")
				.toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			NGramIGPair[] randomNgrams = new NGramIGPair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];// 10
			double totalNumberOfAppsInClassB = (double) countApps[1];// 10
			double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double numberOfAppsHoldNgramInClassA = (double) values[0];
				double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
				double numberOfAppsHoldNgramInClassB = (double) values[1];
				double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

				// Calculation formula of information gain: For details see the
				// paper of Kolter et. al and Reddy et. al.
				double[] informationGainForNgram = new double[4];
				informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				// Skip infinite and NaN terms
				double informationGainForNgramTotal = 0.0;
				for (int i = 0; i < informationGainForNgram.length; i++) {
					if (!(Double.isNaN(informationGainForNgram[i]) || !Double
							.isFinite(informationGainForNgram[i]))) {
						informationGainForNgramTotal += informationGainForNgram[i];
					}
				}
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
				randomNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Information Gain" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Information Gain" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysing Information Gains... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractDistinctiveNgramsByClasswiseIG(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE + "distinctive_" + ngramSize + "-grams_by_classwise_ig.tsv")
				.toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
			// This structure will keep the top-ranked ngrams with their
			// information gain
			NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
			NGramIGPair[] topRankedNgramsForClassA = new NGramIGPair[topRankedSize / 2];
			NGramIGPair[] topRankedNgramsForClassB = new NGramIGPair[topRankedSize / 2];

			// This structure is defined to validate the distribution of
			// information gain scores
			NGramIGPair[] randomNgrams = new NGramIGPair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];// 10
			double totalNumberOfAppsInClassB = (double) countApps[1];// 10
			double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double numberOfAppsHoldNgramInClassA = (double) values[0];
				double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
				double numberOfAppsHoldNgramInClassB = (double) values[1];
				double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

				// Calculation formula of information gain: For details see the
				// paper of Kolter et. al and Reddy et. al.
				double[] informationGainForNgram = new double[4];
				informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				// Skip infinite and NaN terms
				double informationGainForNgramTotal = 0.0;
				for (int i = 0; i < informationGainForNgram.length; i++) {
					if (!(Double.isNaN(informationGainForNgram[i]) || !Double
							.isFinite(informationGainForNgram[i]))) {
						informationGainForNgramTotal += informationGainForNgram[i];
					}
				}
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedSize / 2; i++) {
				topRankedNgramsForClassA[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
			}

			for (int i = 0; i < topRankedSize; i++) {
				topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
				randomNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
			}
			boolean taxon = true;
			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);
				double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);

				Short[] counts = ngrams.get(entry.getKey());
				taxon = (counts[0] >= counts[1]);

				if (taxon) {
					if (entry.getValue() > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				} else {
					if (entry.getValue() > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgramsForClassA);
			Arrays.sort(topRankedNgramsForClassB);
			int index = 0;
			int indexClass = 0;
			while (index < topRankedNgrams.length) {
				topRankedNgrams[index] = topRankedNgramsForClassA[indexClass];
				topRankedNgrams[++index] = topRankedNgramsForClassB[indexClass];
				index++;
				indexClass++;
			}
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Information Gain" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Information Gain" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1)
						+ Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey()
						+ Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue()
						+ Constants.TAB_CHAR
						+ (((i % 2) == 1) ? Constants.CLASS_A_NAME
								: Constants.CLASS_B_NAME) + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1)
						+ Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey()
						+ Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue()
						+ Constants.TAB_CHAR
						+ (((i % 2) == 1) ? Constants.CLASS_A_NAME
								: Constants.CLASS_B_NAME) + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out
					.println("Analysing Classwise Information Gains... Elapsed Time:"
							+ (double) watch.getTime()
							/ 1000.0
							+ " secs."
							+ "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static HashMap<String, Double[]> calculateCondProbsOfNgrams(
			HashMap<String, Short[]> ngrams) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		String ngramsCondProbPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ "cond_probs_of_" + ngramSize + "-grams.tsv").toLowerCase();
		File ngramsCondProbFile = new File(ngramsCondProbPath);

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(ngramsCondProbFile);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|S_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {

			// Retrieve the number of apps for each class
			Short[] appCountPerClass = ngrams
					.get(Constants.COUNT_OF_APPS_PER_CLASS);

			int numberOfClass = appCountPerClass.length;

			double[] totalNumberOfAppsInClass = new double[appCountPerClass.length];
			double totalNumberOfApps = 0.0;
			for (int i = 0; i < appCountPerClass.length; i++) {
				totalNumberOfAppsInClass[i] = (double) appCountPerClass[i];
				totalNumberOfApps += totalNumberOfAppsInClass[i];
			}
			// Calculate prior probability for each class: P(C_i)
			Double[] priors = new Double[numberOfClass];
			for (int i = 0; i < priors.length; i++)
				priors[i] = totalNumberOfAppsInClass[i] / totalNumberOfApps;

			ngramsWithCondProbs.put(Constants.PRIOR_PER_CLASS, priors);

			// Retrieve the number of ngrams for each class
			Integer[] ngramCountPerClass = new Integer[] { 0, 0 };

			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {
				ngramCountPerClass[0] += entry.getValue()[0];
				ngramCountPerClass[1] += entry.getValue()[1];
			}
			int vocabularySize = ngrams.size();
			// Iterate ngram hashmap to calculate conditional probabilities for
			// each ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Double[] condProbs = new Double[numberOfClass];

				Short[] values = entry.getValue();

				for (int i = 0; i < numberOfClass; i++)
					condProbs[i] = (((double) values[i] + 1.0) / ((double) ngramCountPerClass[i] + (double) vocabularySize));

				ngramsWithCondProbs.put(entry.getKey(), condProbs);

			}

			FileUtils.write(ngramsCondProbFile, "NGRAM" + Constants.TAB_CHAR
					+ "CONDITIONAL PROBABILITES", true);
			System.out.print("NGRAM" + Constants.TAB_CHAR
					+ "CONDITIONAL PROBABILITES");

			int count = 0;

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {
				FileUtils
						.write(ngramsCondProbFile, "\n" + entry.getKey(), true);

				for (int i = 0; i < numberOfClass; i++) {
					FileUtils.write(ngramsCondProbFile, Constants.TAB_CHAR
							+ entry.getValue()[i], true);
					System.out.print("\n" + (++count) + Constants.TAB_CHAR
							+ "P(" + entry.getKey() + "|"
							+ Constants.ClassLabel.values()[i].name() + ")"
							+ Constants.TAB_CHAR + entry.getValue()[i]);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> readCondProbsOfNgramsFromFile(
			String filePath) {

		File ngramsCondProbFile = new File(filePath);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {
			List<String> lines = FileUtils.readLines(ngramsCondProbFile);
			int lineNumber = 0;
			for (String line : lines) {
				lineNumber++;
				// Skip header line
				if (line != null && !line.equals("") && lineNumber != 1) {
					String[] tokens = line.split(Constants.TAB_CHAR);
					Double[] probs = new Double[tokens.length - 1];
					for (int i = 0; i < probs.length; i++)
						probs[i] = Double.valueOf(tokens[i + 1]);
					ngramsWithCondProbs.put(tokens[0], probs);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> extractDistinctiveNgramsByCondProbs(
			String filePath, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE + "distinctive_" + ngramSize + "-grams_by_cond_probs.tsv")
				.toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);

		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = readCondProbsOfNgramsFromFile(filePath);
		int topRankedSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
		// This structure will keep the top-ranked ngrams with their information
		// gain

		NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
		NGramIGPair[] topRankedNgramsForClassA = new NGramIGPair[topRankedSize / 2];
		NGramIGPair[] topRankedNgramsForClassB = new NGramIGPair[topRankedSize / 2];

		try {
			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgramsForClassA.length; i++) {
				topRankedNgramsForClassA[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {

				double dif = (entry.getValue()[0] - entry.getValue()[1])
						/ (entry.getValue()[0] + entry.getValue()[1]);
				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				if (dif > 0.0) {
					double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);

					if (entry.getValue()[0] > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new NGramIGPair(
								entry.getKey(), dif);
					}
				} else if (dif < 0.0) {
					double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);
					if (entry.getValue()[1] > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new NGramIGPair(
								entry.getKey(), Math.abs(dif));
					}
				}
			}
			// Sort top ranked array and print it to file and console
			topRankedNgrams = ArrayUtils.addAll(topRankedNgramsForClassA,
					topRankedNgramsForClassB);
			Arrays.sort(topRankedNgrams);

			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Class Difference" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Class Difference" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static ArrayList<HashSet<String>> readDistinctiveNgramsFromFile(
			String filePath, ArrayList<Integer> inputSizes) throws IOException {
		ArrayList<HashSet<String>> rankedNgramsSets = new ArrayList<HashSet<String>>();
		for (int j = 0; j < inputSizes.size(); j++) {
			HashSet<String> topRankedNgrams = new HashSet<String>();
			List<String> fileLines = FileUtils.readLines(new File(filePath));
			for (int i = 1; i <= inputSizes.get(j); i++) {
				String[] values = fileLines.get(i).split(Constants.TAB_CHAR);
				topRankedNgrams.add(values[1]);
			}
			rankedNgramsSets.add(topRankedNgrams);
		}
		return rankedNgramsSets;
	}

	public static HashSet<String> readDistinctiveNgramsFromFile(String filePath)
			throws IOException {
		HashSet<String> topRankedNgrams = new HashSet<String>();
		List<String> fileLines = FileUtils.readLines(new File(filePath));
		int numberOfDataInput = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NUMBER_OF_DATA_INPUT_CONFIG));
		for (int i = 1; i <= numberOfDataInput; i++) {
			String[] values = fileLines.get(i).split(Constants.TAB_CHAR);
			topRankedNgrams.add(values[1]);
		}
		return topRankedNgrams;
	}

	public static void generateDistinctiveNgramsFiles(String dataPath,
			String extension, boolean isTestData) {
		HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension,
				isTestData);
		extractDistinctiveNgramsByClasswiseIG(ngrams, extension);
		// if (extension.equals(Constants.CLASS_EXTENSION))
		// calculateCondProbsOfNgrams(ngrams);
	}

	public static String prepareWekaFileHeader(HashSet<String> topRankedNgrams,
			String extension, boolean isTestData, int numberOfDataInput)
			throws IOException {
		// Data class label for reports and  input files
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

		String trainOrTestLabel = isTestData ? Constants.TEST_LABEL
				: Constants.TRAIN_LABEL;

		// Generate data file and prepare it with its headers
		String wekaDataFilePath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (trainOrTestLabel
				+ Constants.UNDERSCORE
				+ extension
				+ Constants.UNDERSCORE
				+ ngramSize
				+ "-grams"
				+ Constants.UNDERSCORE
				+ numberOfDataInput + ".arff").toLowerCase();

		File wekaDataFile = new File(wekaDataFilePath);
		FileUtils.deleteQuietly(wekaDataFile);

		FileUtils
				.write(wekaDataFile,
						"%%%\n"
								+ "% This "
								+ trainOrTestLabel.toLowerCase()
								+ " data file consists of the most distictive ngrams extracted\n"
								+ "% from reversed engineered *."
								+ extension
								+ " files of known Android apps\n"
								+ "% to classify unknown Anroid apps as "
								+ Constants.CLASS_A_NAME.toLowerCase()
								+ " or "
								+ Constants.CLASS_B_NAME.toLowerCase()
								+ " application\n"
								+ "% by using Weka classifier algorithms. The study is being conducted\n"
								+ "% by Munir Geden and Jens Krinke as part of a research in UCL.\n"
								+ "%\n" + "@relation 'ngram'\n", true);

		FileUtils.write(wekaDataFile, "@attribute appname string\n", true);
		for (String entry : topRankedNgrams) {
			FileUtils.write(wekaDataFile, "@attribute " + entry + " numeric\n",
					true);
		}

		FileUtils.write(wekaDataFile,
				"@attribute class {" + Constants.CLASS_A_NAME + ","
						+ Constants.CLASS_B_NAME + "}\n", true);
		FileUtils.write(wekaDataFile, "@data\n", true);
		return wekaDataFilePath;
	}

	public static void prepareWekaFileDataPerApp(
			ArrayList<HashSet<String>> topRankedNgramsListSet, String appPath,
			ArrayList<String> dataFilePaths, String extension,
			boolean isTestData) {

		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

			// Arff file that will keep training data values
			ArrayList<File> dataFiles = new ArrayList<File>();
			for (String s : dataFilePaths)
				dataFiles.add(new File(s));

			// Collect all files under the path of given app
			Collection<File> files = FileHandler.findFiles(appPath,
					new String[] { extension });

			ArrayList<HashMap<String, Integer>> calculatedDatas = new ArrayList<HashMap<String, Integer>>();
			for (HashSet<String> rankedList : topRankedNgramsListSet) {
				HashMap<String, Integer> calculatedData = new HashMap<String, Integer>();
				for (String entry : rankedList) {
					calculatedData.put(entry, 0);
				}
				calculatedDatas.add(calculatedData);
			}
			// Retrieve class type, its name and its integer array index from
			// file path
			boolean taxon = appPath.contains(File.separator
					+ Constants.CLASS_A_NAME + File.separator);
			String className = taxon ? Constants.CLASS_A_NAME
					: Constants.CLASS_B_NAME;

			// Find appName from path
			String appName = appNameOfFile(appPath, extension);

			// Print iteration information for console
			System.out.print("Analysing app... Class:" + className
					+ Constants.TAB_CHAR + "Extension:" + extension
					+ Constants.TAB_CHAR + "App Name:" + appName + "\n");

			// Number of files traversed
			int fileIterator = -1;

			// Performance monitor watch
			StopWatch watch = new StopWatch();
			watch.reset();
			watch.start();

			// Traverse app files to be analyzed
			for (File file : files) {
				fileIterator++;

				// Read files as byte array and convert them to hexadecimal
				// strings
				byte[] fileHex = FileHandler.readFileToByteArray(file
						.getAbsolutePath());
				for (int i = 0; i < fileHex.length - (ngramSize - 1); i++) {
					StringBuilder sb = new StringBuilder();
					for (int j = 0; j < ngramSize; j++) {
						// if (fileHex[i + j] != 0)
						sb.append(String.format("%02X", fileHex[i + j]));

					}
					String ngram = sb.toString();
					for (int k = 0; k < topRankedNgramsListSet.size(); k++) {
						if (topRankedNgramsListSet.get(k).contains(ngram)) {
							if (calculatedDatas.get(k).containsKey(ngram)) {
								calculatedDatas.get(k).put(ngram, 1);
							}
						}
					}
				}
			}

			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.print("Completed... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs."
					+ Constants.TAB_CHAR + "Number of Files:"
					+ (fileIterator + 1) + "\n");

			for (int k = 0; k < topRankedNgramsListSet.size(); k++) {

				// Append app inputs to arff file
				FileUtils.write(dataFiles.get(k), appName + ",", true);
				for (Map.Entry<String, Integer> entry : calculatedDatas.get(k)
						.entrySet()) {
					FileUtils.write(dataFiles.get(k), entry.getValue() + ",",
							true);
				}
				FileUtils.write(dataFiles.get(k), className + "\n", true);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void prepareWekaFiles(String topRankedFeaturesFile,
			String dataPath, String extension, boolean isTestData,
			ArrayList<Integer> inputSizes) {
		try {
			ArrayList<HashSet<String>> rankedNgramsSets = readDistinctiveNgramsFromFile(
					topRankedFeaturesFile, inputSizes);
			ArrayList<String> dataFilePaths = new ArrayList<String>();
			for (int i = 0; i < rankedNgramsSets.size(); i++) {
				HashSet<String> topRankedNgrams = rankedNgramsSets.get(i);
				String dataFilePath = prepareWekaFileHeader(topRankedNgrams,
						extension, isTestData, inputSizes.get(i));
				dataFilePaths.add(dataFilePath);
			}
			String[] appPaths = appPathsOfGivenClass(dataPath, extension,
					isTestData);
			for (String appPath : appPaths) {
				prepareWekaFileDataPerApp(rankedNgramsSets, appPath,
						dataFilePaths, extension, isTestData);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	private static String[] appPathsOfGivenClass(String dataPath,
			String extension, boolean isTestData) {
		String dataTypeFolder = "";
		if (!(dataPath.contains(File.separator + Constants.TEST_LABEL
				+ File.separator) || dataPath.contains(File.separator
				+ Constants.TRAIN_LABEL + File.separator))) {
			dataTypeFolder = isTestData ? Constants.TEST_LABEL
					: Constants.TRAIN_LABEL;
		}
		String classPathA = dataPath + File.separator + dataTypeFolder
				+ File.separator + Constants.CLASS_A_NAME + File.separator
				+ extension.toUpperCase() + File.separator;
		String classPathB = dataPath + File.separator + dataTypeFolder
				+ File.separator + Constants.CLASS_B_NAME + File.separator
				+ extension.toUpperCase() + File.separator;
		String[] appPaths = ArrayUtils.addAll(
				FileHandler.findFolderContents(classPathA),
				FileHandler.findFolderContents(classPathB));
		return appPaths;
	}

	private static String appNameOfFile(String appPath, String extension) {
		// Retrieve app name from file path
		if (appPath.contains(Constants.UNDERSCORE + extension.toUpperCase())) {
			String[] folders = appPath.substring(
					0,
					appPath.lastIndexOf(Constants.UNDERSCORE
							+ extension.toUpperCase())).split(File.separator);
			return folders[folders.length - 1];
		} else {
			String[] folders = appPath.split(File.separator);
			return folders[folders.length - 1];
		}

	}

	private static double[] minIndexAndValue(NGramIGPair[] arr) {
		double minValue = Double.MAX_VALUE;
		int minIndex = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getValue() < minValue) {
				minValue = arr[i].getValue();
				minIndex = i;
			}
		}
		return new double[] { (double) minIndex, minValue };
	}

	public static int randWithinRange(int min, int max) {
		Random rand = new Random();
		int numValue = rand.nextInt((max - min) + 1) + min;
		return numValue;
	}

}

class NGramIGPair implements Comparable<NGramIGPair> {

	private String key;
	private double value;

	public NGramIGPair(String key, double value) {
		this.key = key;
		this.value = value;
	}

	/**
	 * @return the key
	 */
	public String getKey() {
		return key;
	}

	/**
	 * @param key
	 *            the key to set
	 */
	public void setKey(String key) {
		this.key = key;
	}

	/**
	 * @return the value
	 */
	public double getValue() {
		return value;
	}

	/**
	 * @param value
	 *            the value to set
	 */
	public void setValue(double value) {
		this.value = value;
	}

	@Override
	public int compareTo(NGramIGPair item) {
		if (this.value < item.value) {
			return 1;
		} else if (this.value > item.value) {
			return -1;
		} else {
			return 0;
		}
	}
}