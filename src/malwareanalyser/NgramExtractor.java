/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.util.*;
import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.time.StopWatch;

/**
 *
 * @author msgeden
 */
public class NgramExtractor {

	public static HashMap<String, Short[]> constructNgramsPerApp(
			HashMap<String, Short[]> cumulativeNgrams, String appPath,
			String extension, boolean isTestData, File reportFile) {

		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			// Collect all files under the path of given app
			Collection<File> files = FileHandler.findFiles(appPath,
					new String[] { extension });

			// This will keep the information whether given app owns ngrams
			HashSet<String> ngrams = new HashSet<String>();

			// Retrieve class type, its name and its integer array index from
			// file path
			boolean taxon = appPath.contains(File.separator
					+ FileHandler.readConfigValue(Constants.CLASS_A_NAME_CONFIG) + File.separator);
			String className = taxon ? FileHandler.readConfigValue(Constants.CLASS_A_NAME_CONFIG)
					: FileHandler.readConfigValue(Constants.CLASS_B_NAME_CONFIG);
			int classFrequencyIndex = taxon ? 0 : 1;

			// Retrieve app name from file path
			String[] folders = appPath.split(File.separator);
			String appName = folders[folders.length - 1];
			// Number of files traversed
			int fileIterator = -1;

			// Performance monitor watch
			StopWatch watch = new StopWatch();
			watch.reset();
			watch.start();

			// Traverse app files to be analyzed
			for (File file : files) {
				fileIterator++;

				// Read files as byte array and convert them to hexadecimal
				// strings
				byte[] fileHex = FileHandler.readFileToByteArray(file
						.getAbsolutePath());
				for (int i = 0; i < fileHex.length - (ngramSize - 1); i++) {
					StringBuilder sb = new StringBuilder();
					for (int j = 0; j < ngramSize; j++) {
						// if (fileHex[i + j] != 0)
						sb.append(String.format("%02X", fileHex[i + j]));

					}
					String ngram = sb.toString();
					ngrams.add(ngram);
				}
			}
			// Merge app ngram set with cumulative ngram hashmap
			for (String ngram : ngrams) {
				if (cumulativeNgrams.containsKey(ngram)) {
					Short[] classFrequencies = cumulativeNgrams.get(ngram);
					classFrequencies[classFrequencyIndex] = (short) (classFrequencies[classFrequencyIndex] + 1);
					cumulativeNgrams.put(ngram, classFrequencies);
				} else {
					Short[] classFrequencies = new Short[] { 0, 0 };
					classFrequencies[classFrequencyIndex] = 1;
					cumulativeNgrams.put(ngram, classFrequencies);
				}
			}

			// These values are stored in ngrams hashmap not to iterate once
			// more during the information gain calculation
			if (cumulativeNgrams.containsKey(Constants.COUNT_OF_APPS_PER_CLASS)) {
				Short[] appCountsForClasses = cumulativeNgrams
						.get(Constants.COUNT_OF_APPS_PER_CLASS);
				appCountsForClasses[classFrequencyIndex] = (short) (appCountsForClasses[classFrequencyIndex] + 1);
				cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS,
						appCountsForClasses);
			} else {
				Short[] appCountsForClasses = new Short[] { 0, 0 };
				appCountsForClasses[classFrequencyIndex] = 1;
				cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS,
						appCountsForClasses);
			}

			// Print the number of unique ngrams, files are processed.
			// Print the number of unique ngrams, files are processed.
			FileUtils.write(reportFile, className + Constants.TAB_CHAR
					+ extension + Constants.TAB_CHAR + ngrams.size()
					+ Constants.TAB_CHAR + cumulativeNgrams.size()
					+ Constants.TAB_CHAR + (fileIterator + 1)
					+ Constants.TAB_CHAR + (double) watch.getTime() / 1000.0
					+ Constants.TAB_CHAR + appName + "\n", true);
			System.out.print(className + Constants.TAB_CHAR + extension
					+ Constants.TAB_CHAR + ngrams.size() + Constants.TAB_CHAR
					+ cumulativeNgrams.size() + Constants.TAB_CHAR
					+ (fileIterator + 1) + Constants.TAB_CHAR
					+ (double) watch.getTime() / 1000.0 + Constants.TAB_CHAR
					+ appName + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return cumulativeNgrams;
	}

	public static HashMap<String, Short[]> constructNgrams(String dataPath,
			String extension, boolean isTestData) {

		HashMap<String, Short[]> ngrams = new HashMap<String, Short[]>();
		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			String[] appPaths = appPathsOfGivenClass(dataPath, extension,
					isTestData);

			// Data class label for reports and input files
			String trainOrTestLabel = isTestData ? Constants.TEST_LABEL
					: Constants.TRAIN_LABEL;

			// Generate report file name
			String reportFilePath = (FileHandler
					.readConfigValue(Constants.REPORTS_PATH_CONFIG)
					+ trainOrTestLabel
					+ Constants.UNDERSCORE
					+ extension
					+ Constants.UNDERSCORE
					+ "ngram"
					+ Constants.UNDERSCORE
					+ ngramSize + Constants.UNDERSCORE + "report.tsv")
					.toLowerCase();

			File reportFile = new File(reportFilePath);
			FileUtils.deleteQuietly(reportFile);
			
			FileUtils.write(reportFile, "Class" + Constants.TAB_CHAR
					+ "Extension" + Constants.TAB_CHAR + "# of Ngrams"
					+ Constants.TAB_CHAR + "# of Total Ngrams"
					+ Constants.TAB_CHAR + "Number of Files"
					+ Constants.TAB_CHAR + "Time Elapsed" + Constants.TAB_CHAR
					+ "App Name" + Constants.TAB_CHAR + "\n", true);
			System.out.print("Number" + Constants.TAB_CHAR + "Class"
					+ Constants.TAB_CHAR + "Extension" + Constants.TAB_CHAR
					+ "# of Ngrams" + Constants.TAB_CHAR + "# of Total Ngrams"
					+ Constants.TAB_CHAR + "Number of Files"
					+ Constants.TAB_CHAR + "Time Elapsed" + Constants.TAB_CHAR
					+ "App Name" + Constants.TAB_CHAR + "\n");
			int count = 0;
			for (String appPath : appPaths) {
				System.out.print((++count) + Constants.TAB_CHAR);
				ngrams = constructNgramsPerApp(ngrams, appPath, extension,
						isTestData, reportFile);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngrams;
	}

	public static String extractIGOfNgrams(HashMap<String, Short[]> ngrams,
			String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String randomNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)  + extension
				+ Constants.UNDERSCORE + "random_ngrams_ig"
				+ Constants.UNDERSCORE + ngramSize + ".tsv")
				.toLowerCase();
		File randomNgramsFile = new File(randomNgramsPath);

		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG) + extension
				+ Constants.UNDERSCORE + "topranked_ngrams_ig"
				+ Constants.UNDERSCORE + ngramSize + ".tsv")
				.toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(randomNgramsFile);
		FileUtils.deleteQuietly(rankedNgramsFile);

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();
			
			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
			
			// This structure will keep the top-ranked ngrams with their
			// information gain
			NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			NGramIGPair[] randomNgrams = new NGramIGPair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];// 10
			double totalNumberOfAppsInClassB = (double) countApps[1];// 10
			double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double numberOfAppsHoldNgramInClassA = (double) values[0];
				double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
				double numberOfAppsHoldNgramInClassB = (double) values[1];
				double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

				// Calculation formula of information gain: For details see the
				// paper of Kolter et. al and Reddy et. al.
				double[] informationGainForNgram = new double[4];
				informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				// Skip infinite and NaN terms
				double informationGainForNgramTotal = 0.0;
				for (int i = 0; i < informationGainForNgram.length; i++) {
					if (!(Double.isNaN(informationGainForNgram[i]) || !Double
							.isFinite(informationGainForNgram[i]))) {
						informationGainForNgramTotal += informationGainForNgram[i];
					}
				}
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
				randomNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0,
							topRankedSize - 1)] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Information Gain" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Information Gain" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			// Print random array to file and console without sorting
			FileUtils.write(randomNgramsFile, "Line" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Information Gain" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Information Gain" + "\n");

			for (int i = 0; i < randomNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n");
				FileUtils.write(randomNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysing Information Gains... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractRelevantNgrams(HashMap<String, Short[]> ngrams,
			String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "topranked_ngrams_relevant_classwise"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);

		try {

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
			// This structure will keep the top-ranked ngrams with their
			// information gain
			NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
			NGramIGPair[] topRankedNgramsForClassA = new NGramIGPair[topRankedSize / 2];
			NGramIGPair[] topRankedNgramsForClassB = new NGramIGPair[topRankedSize / 2];
			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedSize / 2; i++) {
				topRankedNgramsForClassA[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
			}
			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);
				double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);
				if ((double)entry.getValue()[0] > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new NGramIGPair(
								entry.getKey(), (double)entry.getValue()[0]);
				}
				if ((double)entry.getValue()[1] > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new NGramIGPair(
								entry.getKey(), (double)entry.getValue()[1]);
				}
			}

			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgramsForClassA);
			Arrays.sort(topRankedNgramsForClassB);
			for (int i = 0; i < topRankedSize; i++) {
				if (i<topRankedSize/2)
					topRankedNgrams[i] = topRankedNgramsForClassA[i];
				else
					topRankedNgrams[i] = topRankedNgramsForClassB[i-topRankedSize/2];
			}
			
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Frequency" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Frequency" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysing Document Frequencies... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractIGOfNgramsClasswise(HashMap<String, Short[]> ngrams,
			String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String randomNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "random_ngrams_ig_classwise"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File randomNgramsFile = new File(randomNgramsPath);

		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "topranked_ngrams_ig_classwise"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(randomNgramsFile);
		FileUtils.deleteQuietly(rankedNgramsFile);

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
			// This structure will keep the top-ranked ngrams with their
			// information gain
			NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
			NGramIGPair[] topRankedNgramsForClassA = new NGramIGPair[topRankedSize / 2];
			NGramIGPair[] topRankedNgramsForClassB = new NGramIGPair[topRankedSize / 2];

			// This structure is defined to validate the distribution of
			// information gain scores
			NGramIGPair[] randomNgrams = new NGramIGPair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];// 10
			double totalNumberOfAppsInClassB = (double) countApps[1];// 10
			double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double numberOfAppsHoldNgramInClassA = (double) values[0];
				double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
				double numberOfAppsHoldNgramInClassB = (double) values[1];
				double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

				// Calculation formula of information gain: For details see the
				// paper of Kolter et. al and Reddy et. al.
				double[] informationGainForNgram = new double[4];
				informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

				// Skip infinite and NaN terms
				double informationGainForNgramTotal = 0.0;
				for (int i = 0; i < informationGainForNgram.length; i++) {
					if (!(Double.isNaN(informationGainForNgram[i]) || !Double
							.isFinite(informationGainForNgram[i]))) {
						informationGainForNgramTotal += informationGainForNgram[i];
					}
				}
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedSize / 2; i++) {
				topRankedNgramsForClassA[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
			}

			for (int i = 0; i < topRankedSize; i++) {
				topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
				randomNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
			}
			boolean taxon = true;
			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);
				double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);
				
				Short[] counts = ngrams.get(entry.getKey());
				taxon = (counts[0] >= counts[1]);

				if (taxon) {
					if (entry.getValue() > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				} else {
					if (entry.getValue() > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgramsForClassA);
			Arrays.sort(topRankedNgramsForClassB);
			int index=0;
			int indexClass=0;
			while (index<topRankedNgrams.length)
			{
				topRankedNgrams[index] = topRankedNgramsForClassA[indexClass];
				topRankedNgrams[++index] = topRankedNgramsForClassB[indexClass];
				index++;indexClass++;
			}
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Information Gain" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Information Gain" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			// Print random array to file and console without sorting
			FileUtils.write(randomNgramsFile, "Line" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Information Gain" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Information Gain" + "\n");

			for (int i = 0; i < randomNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n");
				FileUtils.write(randomNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysing Information Gains... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractEntropyOfNgrams(
			HashMap<String, Short[]> ngrams, String extension) {

		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String randomNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "random_ngrams_entropy"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File randomNgramsFile = new File(randomNgramsPath);

		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "topranked_ngrams_entropy"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(randomNgramsFile);
		FileUtils.deleteQuietly(rankedNgramsFile);

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithEntropy = new HashMap<String, Double>();
			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
			// This structure will keep the top-ranked ngrams with their
			// information gain
			NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
			NGramIGPair[] topRankedNgramsForClassA = new NGramIGPair[topRankedSize / 2];
			NGramIGPair[] topRankedNgramsForClassB = new NGramIGPair[topRankedSize / 2];
			// This structure is defined to validate the distribution of
			// information gain scores
			NGramIGPair[] randomNgrams = new NGramIGPair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				int sum = 0;
				for (int i = 0; i < values.length; i++)
					sum += values[i];
				double entropy = 0.0;
				for (int i = 0; i < countApps.length; i++) {

					double p = (double) values[i] / (double) sum;
					if (p == 0.0 || p == 1.0)
						continue;
					entropy += (p * (Math.log(p) / Math.log(2.0)));
				}
				entropy = -1 * entropy;
				// Add calculated entropy for the given ngram
				if (entropy > 0.0)
					ngramsWithEntropy.put(entry.getKey(), entropy);
				else
					ngramsWithEntropy.put(entry.getKey(), 1.0);
			}
			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedSize / 2; i++) {
				topRankedNgramsForClassA[i] = new NGramIGPair(
						Integer.toString(i), 1.0);
				topRankedNgramsForClassB[i] = new NGramIGPair(
						Integer.toString(i), 1.0);
			}

			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 1.0);
				randomNgrams[i] = new NGramIGPair(Integer.toString(i), 1.0);
			}
			boolean taxon = true;
			for (Map.Entry<String, Double> entry : ngramsWithEntropy.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] maxIGA = maxIndexAndValue(topRankedNgramsForClassA);
				double[] maxIGB = maxIndexAndValue(topRankedNgramsForClassB);
				Short[] counts = ngrams.get(entry.getKey());
				taxon = (counts[0] >= counts[1]);
				if (taxon) {
					if (entry.getValue() < maxIGA[1]) {
						topRankedNgramsForClassA[(int) maxIGA[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				} else {
					if (entry.getValue() < maxIGB[1]) {
						topRankedNgramsForClassB[(int) maxIGB[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				}
				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() < 1.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgramsForClassA, Collections.reverseOrder());
			Arrays.sort(topRankedNgramsForClassB, Collections.reverseOrder());
			int index=0;
			int indexClass=0;
			while (index<topRankedNgrams.length)
			{
				topRankedNgrams[index] = topRankedNgramsForClassA[indexClass];
				topRankedNgrams[++index] = topRankedNgramsForClassB[indexClass];
				index++;indexClass++;
			}
			
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Entropy" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Entropy" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			// Print random array to file and console without sorting
			FileUtils.write(randomNgramsFile, "Line" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Entropy" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Entropy" + "\n");

			for (int i = 0; i < randomNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n");
				FileUtils.write(randomNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysing Entropies... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractSalienceOfNgrams(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String randomNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "random_ngrams_salience"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File randomNgramsFile = new File(randomNgramsPath);

		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "topranked_ngrams_salience"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(randomNgramsFile);
		FileUtils.deleteQuietly(rankedNgramsFile);
		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithSalience = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
			// This structure will keep the top-ranked ngrams with their
			// information gain
			NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
			NGramIGPair[] topRankedNgramsForClassA = new NGramIGPair[topRankedSize / 2];
			NGramIGPair[] topRankedNgramsForClassB = new NGramIGPair[topRankedSize / 2];
			// This structure is defined to validate the distribution of
			// information gain scores
			NGramIGPair[] randomNgrams = new NGramIGPair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double threshold = Double.parseDouble(FileHandler
					.readConfigValue(Constants.SALIENCE_THRESHOLD_CONFIG));

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for salience calculation
				int N = values.length;
				double salience = 0.0;
				for (int i = 0; i < N - 1; i++) {
					double p_g_si = (double) values[i] / (double) countApps[i];
					for (int j = i + 1; j < N; j++) {
						double p_g_sj = (double) values[j]
								/ (double) countApps[j];
						double denom = (Double.min(p_g_si, p_g_sj) / Double
								.max(p_g_si, p_g_sj));
						if (Double.isNaN(denom))
							denom = 0.0;
						salience += (1 - denom);
					}
				}
				salience /= N;
				// Add calculated salience for the given ngram
				if (salience >= threshold && salience < 1.0)
					ngramsWithSalience.put(entry.getKey(), salience);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedSize / 2; i++) {
				topRankedNgramsForClassA[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
			}

			for (int i = 0; i < topRankedSize; i++) {
				topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
				randomNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
			}
			boolean taxon = true;

			for (Map.Entry<String, Double> entry : ngramsWithSalience
					.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);
				double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);
				Short[] counts = ngrams.get(entry.getKey());
				taxon = (counts[0] >= counts[1]);

				if (taxon) {
					if (entry.getValue() > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				} else {
					if (entry.getValue() > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new NGramIGPair(
								entry.getKey(), entry.getValue());
					}
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgramsForClassA);
			Arrays.sort(topRankedNgramsForClassB);
			int index=0;
			int indexClass=0;
			while (index<topRankedNgrams.length)
			{
				topRankedNgrams[index] = topRankedNgramsForClassA[indexClass];
				topRankedNgrams[++index] = topRankedNgramsForClassB[indexClass];
				index++;indexClass++;
			}
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Salience" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Salience" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			// Print random array to file and console without sorting
			FileUtils.write(randomNgramsFile, "Line" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Salience" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Salience" + "\n");

			for (int i = 0; i < randomNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n");
				FileUtils.write(randomNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysing Saliences... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static HashMap<String, Double[]> calculateCondProbsOfNgrams(
			HashMap<String, Short[]> ngrams) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		String ngramsCondProbPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ "condprob_ngrams" + Constants.UNDERSCORE + ngramSize + ".tsv")
				.toLowerCase();
		File ngramsCondProbFile = new File(ngramsCondProbPath);

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(ngramsCondProbFile);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|S_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {

			// Retrieve the number of apps for each class
			Short[] appCountPerClass = ngrams
					.get(Constants.COUNT_OF_APPS_PER_CLASS);

			int numberOfClass = appCountPerClass.length;

			double[] totalNumberOfAppsInClass = new double[appCountPerClass.length];
			double totalNumberOfApps = 0.0;
			for (int i = 0; i < appCountPerClass.length; i++) {
				totalNumberOfAppsInClass[i] = (double) appCountPerClass[i];
				totalNumberOfApps += totalNumberOfAppsInClass[i];
			}
			// Calculate prior probability for each class: P(S_i)
			Double[] priors = new Double[numberOfClass];
			for (int i = 0; i < priors.length; i++)
				priors[i] = totalNumberOfAppsInClass[i] / totalNumberOfApps;

			ngramsWithCondProbs.put(Constants.PRIOR_PER_CLASS, priors);

			// Retrieve the number of ngrams for each class
			Integer[] ngramCountPerClass = new Integer[] { 0, 0 };

			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {
				ngramCountPerClass[0] += entry.getValue()[0];
				ngramCountPerClass[1] += entry.getValue()[1];
			}
			int vocabularySize = ngrams.size();
			// Iterate ngram hashmap to calculate conditional probabilities for
			// each ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Double[] condProbs = new Double[numberOfClass];

				Short[] values = entry.getValue();

				for (int i = 0; i < numberOfClass; i++)
					condProbs[i] = (((double) values[i] + 1.0) / ((double) ngramCountPerClass[i] + (double) vocabularySize));

				ngramsWithCondProbs.put(entry.getKey(), condProbs);

			}

			FileUtils.write(ngramsCondProbFile, "NGRAM" + Constants.TAB_CHAR
					+ "CONDITIONAL PROBABILITES", true);
			System.out.print("NGRAM" + Constants.TAB_CHAR
					+ "CONDITIONAL PROBABILITES");
			
			int count = 0;

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {
				FileUtils
						.write(ngramsCondProbFile, "\n" + entry.getKey(), true);

				for (int i = 0; i < numberOfClass; i++) {
					FileUtils.write(ngramsCondProbFile, Constants.TAB_CHAR
							+ entry.getValue()[i], true);
					System.out.print("\n" + (++count) + Constants.TAB_CHAR
							+ "P(" + entry.getKey() + "|"
							+ Constants.ClassLabel.values()[i].name() + ")"
							+ Constants.TAB_CHAR + entry.getValue()[i]);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> readCondProbsOfNgramsFromFile(
			String filePath) {

		File ngramsCondProbFile = new File(filePath);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {
			List<String> lines = FileUtils.readLines(ngramsCondProbFile);
			int lineNumber = 0;
			for (String line : lines) {
				lineNumber++;
				// Skip header line
				if (line != null && !line.equals("") && lineNumber != 1) {
					String[] tokens = line.split(Constants.TAB_CHAR);
					Double[] probs = new Double[tokens.length - 1];
					for (int i = 0; i < probs.length; i++)
						probs[i] = Double.valueOf(tokens[i + 1]);
					ngramsWithCondProbs.put(tokens[0], probs);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> readDistinctiveNgramsFromCondProbsFile(
			String filePath, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ extension
				+ Constants.UNDERSCORE
				+ "top_ranked_ngrams"
				+ Constants.UNDERSCORE + ngramSize + ".tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);

		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = readCondProbsOfNgramsFromFile(filePath);
		int topRankedSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
		// This structure will keep the top-ranked ngrams with their information
		// gain

		NGramIGPair[] topRankedNgrams = new NGramIGPair[topRankedSize];
		NGramIGPair[] topRankedNgramsForClassA = new NGramIGPair[topRankedSize / 2];
		NGramIGPair[] topRankedNgramsForClassB = new NGramIGPair[topRankedSize / 2];

		try {
					// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgramsForClassA.length; i++) {
				topRankedNgramsForClassA[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new NGramIGPair(
						Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {

				double dif = (entry.getValue()[0] - entry.getValue()[1])
						/ (entry.getValue()[0] + entry.getValue()[1]);
				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				if (dif > 0.0) {
					double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);

					if (entry.getValue()[0] > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new NGramIGPair(
								entry.getKey(), dif);
					}
				} else if (dif < 0.0) {
					double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);
					if (entry.getValue()[1] > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new NGramIGPair(
								entry.getKey(), Math.abs(dif));
					}
				}
			}
			// Sort top ranked array and print it to file and console
			topRankedNgrams = ArrayUtils.addAll(topRankedNgramsForClassA,
					topRankedNgramsForClassB);
			Arrays.sort(topRankedNgrams);

			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Class Difference" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Class Difference" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double> getTopRankedNgrams(String filePath) throws IOException {
		HashMap<String, Double> topRankedNgrams = new HashMap<String,Double>();
		List<String> fileLines = FileUtils.readLines(new File(filePath));
		int numberOfDataInput = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NUMBER_OF_DATA_INPUT_CONFIG));
		for (int i = 1; i <= numberOfDataInput; i++) {
			String[] values = fileLines.get(i).split(Constants.TAB_CHAR);
			topRankedNgrams.put(values[1], Double.parseDouble(values[2]));
		}
		return topRankedNgrams;
	}
	
	public static void generateDistinctiveNgramsFiles(String dataPath,
			String extension, boolean isTestData) {
		HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension,
				isTestData);
		extractRelevantNgrams(ngrams, extension);
		extractIGOfNgramsClasswise(ngrams, extension);
		extractIGOfNgrams(ngrams, extension);
		extractEntropyOfNgrams(ngrams, extension);
		extractSalienceOfNgrams(ngrams, extension);
		//if (extension.equals(Constants.CLASS_EXTENSION))
		//	calculateCondProbsOfNgrams(ngrams);
	}


	public static void generateDistinctiveNgramsFilesWithIG(String dataPath,
			String extension, boolean isTestData) {
		HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension,
				isTestData);
		extractIGOfNgrams(ngrams, extension);
	}
	
	public static void generateDistinctiveNgramsFilesWithEntropy(String dataPath,
			String extension, boolean isTestData) {
		HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension,
				isTestData);
		extractIGOfNgrams(ngrams, extension);
		extractEntropyOfNgrams(ngrams, extension);
		extractSalienceOfNgrams(ngrams, extension);
		if (extension.equals(Constants.CLASS_EXTENSION))
			calculateCondProbsOfNgrams(ngrams);
	}

	public static void generateDistinctiveNgramsFilesWithSalience(String dataPath,
			String extension, boolean isTestData) {
		HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension,
				isTestData);
		extractSalienceOfNgrams(ngrams, extension);
	}

	public static void generateDistinctiveNgramsFilesWithCondProbs(String dataPath,
			String extension, boolean isTestData) {
		HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension,
				isTestData);
		if (extension.equals(Constants.CLASS_EXTENSION))
			calculateCondProbsOfNgrams(ngrams);
	}

	public static String prepareWekaFileHeader(
			HashMap<String, Double> topRankedNgrams, String extension,
			boolean isTestData) throws IOException {
		// Data class label for reports and input files
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

		String trainOrTestLabel = isTestData ? Constants.TEST_LABEL
				: Constants.TRAIN_LABEL;

		int numberOfDataInput = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NUMBER_OF_DATA_INPUT_CONFIG));
		// Generate data file and prepare it with its headers
		String wekaDataFilePath = (FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ trainOrTestLabel
				+ Constants.UNDERSCORE
				+ extension
				+ Constants.UNDERSCORE
				+ "ngram"
				+ Constants.UNDERSCORE
				+ ngramSize + Constants.UNDERSCORE + numberOfDataInput + ".arff")
				.toLowerCase();

		File wekaDataFile = new File(wekaDataFilePath);
		FileUtils.deleteQuietly(wekaDataFile);

		FileUtils
				.write(wekaDataFile,
						"%%%\n"
								+ "% This "
								+ trainOrTestLabel.toLowerCase()
								+ " data file consists of the most distictive ngrams extracted\n"
								+ "% from reversed engineered *."
								+ extension
								+ " files of known Android apps\n"
								+ "% to classify unknown Anroid apps as "
								+ FileHandler.readConfigValue(
										Constants.CLASS_A_NAME_CONFIG)
										.toLowerCase()
								+ " or "
								+ FileHandler.readConfigValue(
										Constants.CLASS_B_NAME_CONFIG)
										.toLowerCase()
								+ " application\n"
								+ "% by using Weka classifier algorithms. The study is being conducted\n"
								+ "% by Munir Geden and Jens Krinke as part of a research in UCL.\n"
								+ "%\n" + "@relation 'ngram'\n", true);

		FileUtils.write(wekaDataFile, "@attribute appname string\n", true);
		for (Map.Entry<String, Double> entry : topRankedNgrams.entrySet()) {
			FileUtils.write(wekaDataFile, "@attribute " + entry.getKey()
					+ " numeric\n", true);
		}

		FileUtils.write(
				wekaDataFile,
				"@attribute class {"
						+ FileHandler
								.readConfigValue(Constants.CLASS_A_NAME_CONFIG)
						+ ","
						+ FileHandler
								.readConfigValue(Constants.CLASS_B_NAME_CONFIG)
						+ "}\n", true);
		FileUtils.write(wekaDataFile, "@data\n", true);
		return wekaDataFilePath;
	}

	public static void prepareWekaFileDataPerApp(
			HashMap<String, Double> topRankedNgrams, String appPath,
			String dataFilePath, String extension, boolean isTestData) {

		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

			// Arff file that will keep training data values
			File dataFile = new File(dataFilePath);

			// Collect all files under the path of given app
			Collection<File> files = FileHandler.findFiles(appPath,
					new String[] { extension });

			// This will keep the calculated values of ngrams: log2(frequency) *
			// information gain
			HashMap<String, Integer> calculatedData = new HashMap<String, Integer>();
			for (Map.Entry<String, Double> entry : topRankedNgrams.entrySet()) {
				calculatedData.put(entry.getKey(), 0);
			}

			// Retrieve class type, its name and its integer array index from
			// file path
			boolean taxon = appPath.contains(File.separator
					+ FileHandler
							.readConfigValue(Constants.CLASS_A_NAME_CONFIG)
					+ File.separator);
			String className = taxon ? FileHandler
					.readConfigValue(Constants.CLASS_A_NAME_CONFIG)
					: FileHandler
							.readConfigValue(Constants.CLASS_B_NAME_CONFIG);

			// Find appName from path
			String appName = appNameOfFile(appPath, extension);

			// Print iteration information for console
			System.out.print("Analysing app... Class:" + className
					+ Constants.TAB_CHAR + "Extension:" + extension
					+ Constants.TAB_CHAR + "App Name:" + appName + "\n");

			// Number of files traversed
			int fileIterator = -1;

			// Performance monitor watch
			StopWatch watch = new StopWatch();
			watch.reset();
			watch.start();

			// Traverse app files to be analyzed
			for (File file : files) {
				fileIterator++;

				// Read files as byte array and convert them to hexadecimal
				// strings
				byte[] fileHex = FileHandler.readFileToByteArray(file
						.getAbsolutePath());
				for (int i = 0; i < fileHex.length - (ngramSize - 1); i++) {
					StringBuilder sb = new StringBuilder();
					for (int j = 0; j < ngramSize; j++) {
						// if (fileHex[i + j] != 0)
						sb.append(String.format("%02X", fileHex[i + j]));

					}
					String ngram = sb.toString();
					if (topRankedNgrams.containsKey(ngram)) {
						if (calculatedData.containsKey(ngram)) {
							calculatedData.put(ngram, 1);
						}
					}
				}
			}

			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.print("Completed... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs."
					+ Constants.TAB_CHAR + "Number of Files:"
					+ (fileIterator + 1) + "\n");

			// Append app inputs to arff file
			FileUtils.write(dataFile, appName + ",", true);
			for (Map.Entry<String, Integer> entry : calculatedData.entrySet()) {
				FileUtils.write(dataFile, entry.getValue() + ",", true);
			}
			FileUtils.write(dataFile, className + "\n", true);

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void prepareWekaFileData(String topRankedFeaturesFile,
			String dataPath, String extension, boolean isTestData) {
		try {
			HashMap<String, Double> topRankedNgrams = new HashMap<String, Double>();
			// readDistinctiveNgramsFromCondProbsFile(Constants.REPORTS_PATH
			// + "condprob_ngrams_4.tsv", extension);
			topRankedNgrams = getTopRankedNgrams(topRankedFeaturesFile);
			String dataFilePath = prepareWekaFileHeader(topRankedNgrams,
					extension, isTestData);
			String[] appPaths = appPathsOfGivenClass(dataPath, extension,
					isTestData);
			for (String appPath : appPaths) {
				prepareWekaFileDataPerApp(topRankedNgrams, appPath,
						dataFilePath, extension, isTestData);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	private static String[] appPathsOfGivenClass(String dataPath,
			String extension, boolean isTestData) {
		String dataTypeFolder = "";
		if (!(dataPath.contains(File.separator + Constants.TEST_LABEL
				+ File.separator) || dataPath.contains(File.separator
				+ Constants.TRAIN_LABEL + File.separator))) {
			dataTypeFolder = isTestData ? Constants.TEST_LABEL
					: Constants.TRAIN_LABEL;
		}
		String classPathA = dataPath + File.separator + dataTypeFolder
				+ File.separator
				+ FileHandler.readConfigValue(Constants.CLASS_A_NAME_CONFIG)
				+ File.separator + extension.toUpperCase() + File.separator;
		String classPathB = dataPath + File.separator + dataTypeFolder
				+ File.separator
				+ FileHandler.readConfigValue(Constants.CLASS_B_NAME_CONFIG)
				+ File.separator + extension.toUpperCase() + File.separator;
		String[] appPaths = ArrayUtils.addAll(
				FileHandler.findFolderContents(classPathA),
				FileHandler.findFolderContents(classPathB));
		return appPaths;
	}

	private static String appNameOfFile(String appPath, String extension) {
		// Retrieve app name from file path
		if (appPath.contains(Constants.UNDERSCORE + extension.toUpperCase())) {
			String[] folders = appPath.substring(
					0,
					appPath.lastIndexOf(Constants.UNDERSCORE
							+ extension.toUpperCase())).split(File.separator);
			return folders[folders.length - 1];
		} else {
			String[] folders = appPath.split(File.separator);
			return folders[folders.length - 1];
		}

	}

	private static double[] minIndexAndValue(NGramIGPair[] arr) {
		double minValue = Double.MAX_VALUE;
		int minIndex = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getValue() < minValue) {
				minValue = arr[i].getValue();
				minIndex = i;
			}
		}
		return new double[] { (double) minIndex, minValue };
	}

	private static double[] maxIndexAndValue(NGramIGPair[] arr) {
		double maxValue = 0.0;
		int maxIndex = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getValue() > maxValue) {
				maxValue = arr[i].getValue();
				maxIndex = i;
			}
		}
		return new double[] { (double) maxIndex, maxValue };
	}

	public static int randWithinRange(int min, int max) {
		Random rand = new Random();
		int numValue = rand.nextInt((max - min) + 1) + min;
		return numValue;
	}

}

class NGramIGPair implements Comparable<NGramIGPair> {

	private String key;
	private double value;

	public NGramIGPair(String key, double value) {
		this.key = key;
		this.value = value;
	}

	/**
	 * @return the key
	 */
	public String getKey() {
		return key;
	}

	/**
	 * @param key
	 *            the key to set
	 */
	public void setKey(String key) {
		this.key = key;
	}

	/**
	 * @return the value
	 */
	public double getValue() {
		return value;
	}

	/**
	 * @param value
	 *            the value to set
	 */
	public void setValue(double value) {
		this.value = value;
	}

	@Override
	public int compareTo(NGramIGPair item) {
		if (this.value < item.value) {
			return 1;
		} else if (this.value > item.value) {
			return -1;
		} else {
			return 0;
		}
	}
}