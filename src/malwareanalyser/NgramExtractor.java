/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.util.*;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;

import javax.xml.bind.DatatypeConverter;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.time.StopWatch;

/**
 *
 * @author msgeden
 */
public class NgramExtractor {
	public static HashMap<String, Short[]> constructNgramsPerApp(
			HashMap<String, Short[]> cumulativeNgrams, String appPath,
			String extension, boolean isTestData, File reportFile) {

		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			// Collect all files under the path of given app
			Collection<File> files = FileHandler.findFiles(appPath,
					new String[] { extension });

			// This will keep the information whether given app owns ngrams
			HashSet<String> ngrams = new HashSet<String>();

			// Retrieve class type, its name and its integer array index from
			// file path
			boolean taxon = appPath.contains(File.separator
					+ Constants.CLASS_A_NAME + File.separator);
			String className = taxon ? Constants.CLASS_A_NAME
					: Constants.CLASS_B_NAME;
			int classFrequencyIndex = taxon ? 0 : 1;

			// Retrieve app name from file path
			String[] folders = appPath.split(File.separator);
			String appName = folders[folders.length - 1];
			// Number of files traversed
			int fileIterator = -1;

			// Performance monitor watch
			StopWatch watch = new StopWatch();
			watch.reset();
			watch.start();

			// Traverse app files to be analyzed
			for (File file : files) {
				fileIterator++;

				// Read files as byte array and convert them to hexadecimal
				// strings
				byte fileHex[];
				if (extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
						|| extension
								.equals(Constants.BERTILLONAGE_DEX_EXTENSION)) {
					fileHex = FileHandler
							.readFileToString(file.getAbsolutePath())
							.replaceAll("H:    [A-Za-z0-9]{32}", "").getBytes();

				} else {
					fileHex = FileHandler.readFileToByteArray(file
							.getAbsolutePath());
				}
				for (int i = 0; i < fileHex.length - (ngramSize - 1); i++) {
					StringBuilder sb = new StringBuilder();
					for (int j = 0; j < ngramSize; j++) {
						// if (fileHex[i + j] != 0)
						sb.append(String.format("%02X", fileHex[i + j]));

					}
					String ngram = sb.toString();
					ngrams.add(ngram);
				}
			}
			// Merge app ngram set with cumulative ngram hashmap
			for (String ngram : ngrams) {
				if (cumulativeNgrams.containsKey(ngram)) {
					Short[] classFrequencies = cumulativeNgrams.get(ngram);
					classFrequencies[classFrequencyIndex] = (short) (classFrequencies[classFrequencyIndex] + 1);
					cumulativeNgrams.put(ngram, classFrequencies);
				} else {
					Short[] classFrequencies = new Short[] { 0, 0 };
					classFrequencies[classFrequencyIndex] = 1;
					cumulativeNgrams.put(ngram, classFrequencies);
				}
			}

			// These values are stored in ngrams hashmap not to iterate once
			// more during the information gain calculation
			if (cumulativeNgrams.containsKey(Constants.COUNT_OF_APPS_PER_CLASS)) {
				Short[] appCountsForClasses = cumulativeNgrams
						.get(Constants.COUNT_OF_APPS_PER_CLASS);
				appCountsForClasses[classFrequencyIndex] = (short) (appCountsForClasses[classFrequencyIndex] + 1);
				cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS,
						appCountsForClasses);
			} else {
				Short[] appCountsForClasses = new Short[] { 0, 0 };
				appCountsForClasses[classFrequencyIndex] = 1;
				cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS,
						appCountsForClasses);
			}

			// Print the number of unique ngrams, files are processed.
			// Print the number of unique ngrams, files are processed.
			FileUtils.write(reportFile, className + Constants.TAB_CHAR
					+ extension + Constants.TAB_CHAR + ngrams.size()
					+ Constants.TAB_CHAR + cumulativeNgrams.size()
					+ Constants.TAB_CHAR + (fileIterator + 1)
					+ Constants.TAB_CHAR + (double) watch.getTime() / 1000.0
					+ Constants.TAB_CHAR + appName + "\n", true);
			System.out.print(className + Constants.TAB_CHAR + extension
					+ Constants.TAB_CHAR + ngrams.size() + Constants.TAB_CHAR
					+ cumulativeNgrams.size() + Constants.TAB_CHAR
					+ (fileIterator + 1) + Constants.TAB_CHAR
					+ (double) watch.getTime() / 1000.0 + Constants.TAB_CHAR
					+ appName + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return cumulativeNgrams;
	}

	public static HashMap<String, Short[]> constructNgrams(String dataPath,
			String extension, boolean isTestData) {

		HashMap<String, Short[]> ngrams = new HashMap<String, Short[]>();
		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			String[] appPaths = appPathsOfGivenClass(dataPath, extension,
					isTestData);

			// Data class label for reports and input files
			String trainOrTestLabel = isTestData ? Constants.TEST_LABEL
					: Constants.TRAIN_LABEL;

			// Generate report file name
			String reportFilePath = FileHandler
					.readConfigValue(Constants.REPORTS_PATH_CONFIG)
					+ (trainOrTestLabel + Constants.UNDERSCORE + extension
							+ Constants.UNDERSCORE + "ngram"
							+ Constants.UNDERSCORE + ngramSize
							+ Constants.UNDERSCORE + "report.tsv")
							.toLowerCase();

			File reportFile = new File(reportFilePath);
			FileUtils.deleteQuietly(reportFile);

			FileUtils.write(reportFile, "Class" + Constants.TAB_CHAR
					+ "Extension" + Constants.TAB_CHAR + "# of Ngrams"
					+ Constants.TAB_CHAR + "# of Total Ngrams"
					+ Constants.TAB_CHAR + "Number of Files"
					+ Constants.TAB_CHAR + "Time Elapsed" + Constants.TAB_CHAR
					+ "App Name" + Constants.TAB_CHAR + "\n", true);
			System.out.print("Number" + Constants.TAB_CHAR + "Class"
					+ Constants.TAB_CHAR + "Extension" + Constants.TAB_CHAR
					+ "# of Ngrams" + Constants.TAB_CHAR + "# of Total Ngrams"
					+ Constants.TAB_CHAR + "Number of Files"
					+ Constants.TAB_CHAR + "Time Elapsed" + Constants.TAB_CHAR
					+ "App Name" + Constants.TAB_CHAR + "\n");
			int count = 0;
			for (String appPath : appPaths) {
				System.out.print((++count) + Constants.TAB_CHAR);
				ngrams = constructNgramsPerApp(ngrams, appPath, extension,
						isTestData, reportFile);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngrams;
	}

	public static String extractDistinctiveNgramsByNormalizedDifference(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_difference.tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Normalized Difference Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];
			double totalNumberOfAppsInClassB = (double) countApps[1];

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double frequencyOfNgramInClassA = (double) values[0];
				double frequencyOfNgramInClassB = (double) values[1];

				double probabilityOfNgramInClassA = (double) values[0]
						/ totalNumberOfAppsInClassA;
				double probabilityOfNgramInClassB = (double) values[1]
						/ totalNumberOfAppsInClassB;

				// log(p(ngram))xdistance
				// Calculation formula of normalized distances
				double distanceScore = Math
						.abs((probabilityOfNgramInClassA - probabilityOfNgramInClassB)
								/ (probabilityOfNgramInClassA + probabilityOfNgramInClassB)
								* Math.log(frequencyOfNgramInClassA
										+ frequencyOfNgramInClassB));
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), distanceScore);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new ScorePair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			if (extension.equals(Constants.SMALI_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION)
					|| extension
							.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION)
					|| extension
							.equals(Constants.PERM_EXTENSION)) {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Difference Score"
						+ Constants.TAB_CHAR + "Text" + "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Difference Score"
						+ Constants.TAB_CHAR + "Text" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1)
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey()
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue()
							+ Constants.TAB_CHAR
							+ new String(
									DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
									"").replace("\t", "") + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1)
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue()
									+ Constants.TAB_CHAR
									+ new String(DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
											"").replace("\t", "") + "\n", true);
				}
			} else {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Difference Score"
						+ "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Difference Score" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1) + Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue() + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1) + Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue() + "\n",
							true);
				}
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysing is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractDistinctiveNgramsByNormalizedDistance(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_distance.tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Normalized Distance Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];
			double totalNumberOfAppsInClassB = (double) countApps[1];

			// ax+by+c, c=0,b=-1
			double a = totalNumberOfAppsInClassB / totalNumberOfAppsInClassB;
			double b = -1.0;
			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double probabilityOfNgramInClassA = (double) values[0]
						/ totalNumberOfAppsInClassA;
				double probabilityOfNgramInClassB = (double) values[1]
						/ totalNumberOfAppsInClassB;
				double probabilityOfNgram = probabilityOfNgramInClassA
						+ probabilityOfNgramInClassB;

				// log(p(ngram))xdistance
				// Calculation formula of normalized distances
				double distanceScore = Math.abs(Math.log(probabilityOfNgram)
						* ((a * probabilityOfNgramInClassA + b
								* probabilityOfNgramInClassB) / Math.sqrt(Math
								.pow(a, 2) + Math.pow(b, 2))));
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), distanceScore);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new ScorePair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			if (extension.equals(Constants.SMALI_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION)
					|| extension
							.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION)
					|| extension
							.equals(Constants.PERM_EXTENSION)) {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Distance Score"
						+ Constants.TAB_CHAR + "Text" + "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Distance Score"
						+ Constants.TAB_CHAR + "Text" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1)
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey()
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue()
							+ Constants.TAB_CHAR
							+ new String(
									DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
									"").replace("\t", "") + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1)
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue()
									+ Constants.TAB_CHAR
									+ new String(DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
											"").replace("\t", "") + "\n", true);
				}
			} else {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Distance Score"
						+ "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Distance Score" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1) + Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue() + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1) + Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue() + "\n",
							true);
				}
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysis is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractDistinctiveNgramsByNormalizedDistanceRatio(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_distance_ratio.tsv")
						.toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Normalized Distance Ratio Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];
			double totalNumberOfAppsInClassB = (double) countApps[1];

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double probabilityOfNgramInClassA = (double) values[0]
						/ totalNumberOfAppsInClassA;
				double probabilityOfNgramInClassB = (double) values[1]
						/ totalNumberOfAppsInClassB;
				double probabilityOfHypotenuse = Math.sqrt(Math.pow(
						probabilityOfNgramInClassA, 2.0)
						+ Math.pow(probabilityOfNgramInClassB, 2.0));
				double normalizer = Math.log(probabilityOfHypotenuse);

				// log(p(ngram))xdistance
				// Calculation formula of normalized distances
				double distanceRatioScore = Math.abs(normalizer
						* Math.sqrt(Math.pow(probabilityOfNgramInClassA
								- probabilityOfNgramInClassB, 2)
								+ Math.pow(probabilityOfNgramInClassB
										- probabilityOfNgramInClassA, 2))
						/ Math.sqrt(probabilityOfHypotenuse)

				);
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), distanceRatioScore);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new ScorePair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			if (extension.equals(Constants.SMALI_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION)
					|| extension
							.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION)
					|| extension
							.equals(Constants.PERM_EXTENSION)) {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Distance Score"
						+ Constants.TAB_CHAR + "Text" + "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Distance Score"
						+ Constants.TAB_CHAR + "Text" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1)
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey()
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue()
							+ Constants.TAB_CHAR
							+ new String(
									DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
									"").replace("\t", "") + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1)
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue()
									+ Constants.TAB_CHAR
									+ new String(DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
											"").replace("\t", "") + "\n", true);
				}
			} else {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Distance Score"
						+ "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Distance Score" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1) + Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue() + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1) + Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue() + "\n",
							true);
				}
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysis is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractDistinctiveNgramsByNormalizedAngle(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_sin.tsv")
						.toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Normalized Sin Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];
			double totalNumberOfAppsInClassB = (double) countApps[1];

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double probabilityOfNgramInClassA = (double) values[0]
						/ totalNumberOfAppsInClassA;
				double probabilityOfNgramInClassB = (double) values[1]
						/ totalNumberOfAppsInClassB;
				double probabilityOfHypotenuse = Math.sqrt(Math.pow(
						probabilityOfNgramInClassA, 2.0)
						+ Math.pow(probabilityOfNgramInClassB, 2.0));
				double absDiff = Math.abs(probabilityOfNgramInClassA-probabilityOfNgramInClassB);
				double sinOfAngle = Math.sqrt(Math.pow(probabilityOfNgramInClassA-probabilityOfNgramInClassB, 2.0)+Math.pow(probabilityOfNgramInClassB-probabilityOfNgramInClassA, 2.0))/(2*probabilityOfHypotenuse);
				double angleUnit = Math.asin(sinOfAngle)/(Math.PI/4); //45=1 0=0
				double normalizer = Math.sqrt(absDiff);

				// log(p(ngram))xdistance
				// Calculation formula of normalized distances
				double distanceRatioScore = normalizer*angleUnit;
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), distanceRatioScore);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new ScorePair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			if (extension.equals(Constants.SMALI_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION)
					|| extension
							.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION)
					|| extension
							.equals(Constants.PERM_EXTENSION)) {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Distance Score"
						+ Constants.TAB_CHAR + "Text" + "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Distance Score"
						+ Constants.TAB_CHAR + "Text" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1)
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey()
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue()
							+ Constants.TAB_CHAR
							+ new String(
									DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
									"").replace("\t", "") + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1)
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue()
									+ Constants.TAB_CHAR
									+ new String(DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
											"").replace("\t", "") + "\n", true);
				}
			} else {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Distance Score"
						+ "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Distance Score" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1) + Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue() + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1) + Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue() + "\n",
							true);
				}
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysis is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}
	public static String extractDistinctiveNgramsByIG(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_ig.tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Information Gain Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);

			double totalNumberOfAppsInClassA = (double) countApps[0];// 10
			double totalNumberOfAppsInClassB = (double) countApps[1];// 10
			double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double numberOfAppsHoldNgramInClassA = (double) values[0];
				double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
				double numberOfAppsHoldNgramInClassB = (double) values[1];
				double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

				// Calculation formula of information gain: For details see the
				// paper of Kolter et. al and Reddy et. al.
				double[] informationGainForNgram = new double[4];
				informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassA / totalNumberOfApps)));

				informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassA / totalNumberOfApps)));

				informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassB / totalNumberOfApps)));

				informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassB / totalNumberOfApps)));

				// Skip infinite and NaN terms
				double informationGainForNgramTotal = 0.0;
				for (int i = 0; i < informationGainForNgram.length; i++) {
					if (!(Double.isNaN(informationGainForNgram[i]) || !Double
							.isFinite(informationGainForNgram[i]))) {
						informationGainForNgramTotal += informationGainForNgram[i];
					}
				}
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new ScorePair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			if (extension.equals(Constants.SMALI_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION)
					|| extension
							.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION)
					|| extension
							.equals(Constants.PERM_EXTENSION)) {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Information Gain"
						+ Constants.TAB_CHAR + "Text" + "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Information Gain"
						+ Constants.TAB_CHAR + "Text" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1)
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey()
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue()
							+ Constants.TAB_CHAR
							+ new String(
									DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
									"").replace("\t", "") + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1)
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue()
									+ Constants.TAB_CHAR
									+ new String(DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
											"").replace("\t", "") + "\n", true);
				}
			} else {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Information Gain"
						+ "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Information Gain" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1) + Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue() + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1) + Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue() + "\n",
							true);
				}
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysis is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractDistinctiveNgramsByClasswiseIG(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_classwise_ig.tsv")
						.toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Classwise Information Gain Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			ScorePair[] topRankedNgramsForClassA = new ScorePair[topRankedSize / 2];
			ScorePair[] topRankedNgramsForClassB = new ScorePair[topRankedSize / 2];

			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			double totalNumberOfAppsInClassA = (double) countApps[0];// 10
			double totalNumberOfAppsInClassB = (double) countApps[1];// 10
			double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				double numberOfAppsHoldNgramInClassA = (double) values[0];
				double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
				double numberOfAppsHoldNgramInClassB = (double) values[1];
				double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

				// Calculation formula of information gain: For details see the
				// paper of Kolter et. al and Reddy et. al.
				double[] informationGainForNgram = new double[4];
				informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassA / totalNumberOfApps)));

				informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
						* Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassA / totalNumberOfApps)));

				informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassB / totalNumberOfApps)));

				informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
						* Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
								/ (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * (totalNumberOfAppsInClassB / totalNumberOfApps)));

				// Skip infinite and NaN terms
				double informationGainForNgramTotal = 0.0;
				for (int i = 0; i < informationGainForNgram.length; i++) {
					if (!(Double.isNaN(informationGainForNgram[i]) || !Double
							.isFinite(informationGainForNgram[i]))) {
						informationGainForNgramTotal += informationGainForNgram[i];
					}
				}
				// Add calculated information gain for the given ngram
				ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedSize / 2; i++) {
				topRankedNgramsForClassA[i] = new ScorePair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new ScorePair(
						Integer.toString(i), 0.0);
			}

			for (int i = 0; i < topRankedSize; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
			}
			boolean taxon = true;
			for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);
				double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);

				Short[] counts = ngrams.get(entry.getKey());
				taxon = (((double) counts[0] / totalNumberOfAppsInClassA) >= ((double) counts[1] / totalNumberOfAppsInClassB));

				if (taxon) {
					if (entry.getValue() > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new ScorePair(
								entry.getKey(), entry.getValue());
					}
				} else {
					if (entry.getValue() > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new ScorePair(
								entry.getKey(), entry.getValue());
					}
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgramsForClassA);
			Arrays.sort(topRankedNgramsForClassB);
			int index = 0;
			int indexClass = 0;
			while (index < topRankedNgrams.length) {
				topRankedNgrams[index] = topRankedNgramsForClassA[indexClass];
				topRankedNgrams[++index] = topRankedNgramsForClassB[indexClass];
				index++;
				indexClass++;
			}
			if (extension.equals(Constants.SMALI_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION)
					|| extension
							.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION)
					|| extension
							.equals(Constants.PERM_EXTENSION)) {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Information Gain"
						+ Constants.TAB_CHAR + "Class" + Constants.TAB_CHAR
						+ "Text" + "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Information Gain"
						+ Constants.TAB_CHAR + "Class" + Constants.TAB_CHAR
						+ "Text" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1)
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey()
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue()
							+ Constants.TAB_CHAR
							+ (((i % 2) == 0) ? Constants.CLASS_A_NAME
									: Constants.CLASS_B_NAME)
							+ Constants.TAB_CHAR
							+ new String(
									DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
									"").replace("\t", "") + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1)
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue()
									+ Constants.TAB_CHAR
									+ (((i % 2) == 0) ? Constants.CLASS_A_NAME
											: Constants.CLASS_B_NAME)
									+ Constants.TAB_CHAR
									+ new String(DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
											"").replace("\t", "") + "\n", true);
				}
			} else {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Information Gain"
						+ "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Information Gain" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1) + Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue() + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1) + Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue() + "\n",
							true);
				}
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysis is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractDistinctiveNgramsByEntropy(
			HashMap<String, Short[]> ngrams, String extension) {

		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

		// Top-ranked ngram features file name generation

		String randomNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "random_" + ngramSize + "-grams_by_entropy.tsv")
						.toLowerCase();
		File randomNgramsFile = new File(randomNgramsPath);

		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_entropy.tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);

		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(randomNgramsFile);
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Entropy Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithEntropy = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				int sum = 0;
				for (int i = 0; i < values.length; i++)
					sum += values[i];
				double entropy = 0.0;
				for (int i = 0; i < countApps.length; i++) {

					double p = (double) values[i] / (double) sum;
					if (p == 0.0 || p == 1.0)
						continue;
					entropy += (p * (Math.log(p) / Math.log(2.0)));
				}
				entropy = -1 * entropy;
				// Add calculated entropy for the given ngram
				if (entropy > 0.0)
					ngramsWithEntropy.put(entry.getKey(), entropy);
				else
					ngramsWithEntropy.put(entry.getKey(), 1.0);
			}
			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 1.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 1.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithEntropy.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] maxIG = maxIndexAndValue(topRankedNgrams);
				if (entry.getValue() < maxIG[1]) {
					topRankedNgrams[(int) maxIG[0]] = new ScorePair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() < 1.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams, Collections.reverseOrder());
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Entropy" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Entropy" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			// Print random array to file and console without sorting
			FileUtils.write(randomNgramsFile, "Line" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Entropy" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Entropy" + "\n");

			for (int i = 0; i < randomNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n");
				FileUtils.write(randomNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysis is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static String extractDistinctiveNgramsBySalience(
			HashMap<String, Short[]> ngrams, String extension) {

		// Top-ranked ngram features file name generation
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

		// Top-ranked ngram features file name generation

		String randomNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "random_" + ngramSize + "-grams_by_salience.tsv")
						.toLowerCase();
		File randomNgramsFile = new File(randomNgramsPath);

		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_salience.tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);
		StopWatch watch = new StopWatch();
		watch.reset();
		watch.start();

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(randomNgramsFile);
		FileUtils.deleteQuietly(rankedNgramsFile);
		System.out.println("Analysing Salience Scores...");

		try {

			// This will keep the information gain extracted from each ngram
			HashMap<String, Double> ngramsWithSalience = new HashMap<String, Double>();

			int topRankedSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));

			// This structure will keep the top-ranked ngrams with their
			// information gain
			ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
			// This structure is defined to validate the distribution of
			// information gain scores
			ScorePair[] randomNgrams = new ScorePair[topRankedSize];

			// Retrieve the number of apps per class from the specific entry
			Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);

			// Remove this specific entry not to interpret as ngram
			// ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

			// Iterate ngram hashmap to calculate information gain for each
			// ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Short[] values = entry.getValue();

				// Terms that are needed for information gain calculation
				int N = values.length;
				double salience = 0.0;
				for (int i = 0; i < N - 1; i++) {
					double p_g_si = (double) values[i] / (double) countApps[i];
					for (int j = i + 1; j < N; j++) {
						double p_g_sj = (double) values[j]
								/ (double) countApps[j];
						double denom = (Double.min(p_g_si, p_g_sj) / Double
								.max(p_g_si, p_g_sj));
						if (Double.isNaN(denom))
							denom = 0.0;
						salience += (1 - denom);
					}
				}
				salience /= N;
				// Add calculated salience for the given ngram
				if (salience < 1.0)
					ngramsWithSalience.put(entry.getKey(), salience);
			}

			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
				randomNgrams[i] = new ScorePair(Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithSalience
					.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] minIG = minIndexAndValue(topRankedNgrams);
				if (entry.getValue() > minIG[1]) {
					topRankedNgrams[(int) minIG[0]] = new ScorePair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() > 0.0) {
					randomNgrams[randWithinRange(0, topRankedSize - 1)] = new ScorePair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams);
			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Salience" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Salience" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
			// Print random array to file and console without sorting
			FileUtils.write(randomNgramsFile, "Line" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Salience" + "\n", true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Salience" + "\n");

			for (int i = 0; i < randomNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n");
				FileUtils.write(randomNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ randomNgrams[i].getKey() + Constants.TAB_CHAR
						+ randomNgrams[i].getValue() + "\n", true);
			}
			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.println("Analysis is finished...Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs." + "\n");

		} catch (Exception e) {
			e.printStackTrace();
		}
		return rankedNgramsFile.getAbsolutePath();
	}

	public static HashMap<String, Double[]> calculateCondProbsOfNgrams(
			HashMap<String, Short[]> ngrams, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		String ngramsCondProbPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + "_cond_probs_of_" + ngramSize + "-grams.tsv")
						.toLowerCase();
		File ngramsCondProbFile = new File(ngramsCondProbPath);

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(ngramsCondProbFile);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {

			// Retrieve the number of apps for each class
			Short[] appCountPerClass = ngrams
					.get(Constants.COUNT_OF_APPS_PER_CLASS);

			int numberOfClass = appCountPerClass.length;

			double[] totalNumberOfAppsInClass = new double[appCountPerClass.length];
			double totalNumberOfApps = 0.0;
			for (int i = 0; i < appCountPerClass.length; i++) {
				totalNumberOfAppsInClass[i] = (double) appCountPerClass[i];
				totalNumberOfApps += totalNumberOfAppsInClass[i];
			}
			// Calculate prior probability for each class: P(C_i)
			Double[] priors = new Double[numberOfClass];
			for (int i = 0; i < priors.length; i++)
				priors[i] = totalNumberOfAppsInClass[i] / totalNumberOfApps;

			ngramsWithCondProbs.put(Constants.PRIOR_PER_CLASS, priors);

			// Retrieve the number of ngrams for each class
			Integer[] ngramCountPerClass = new Integer[] { 0, 0 };

			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {
				ngramCountPerClass[0] += entry.getValue()[0];
				ngramCountPerClass[1] += entry.getValue()[1];
			}
			int vocabularySize = ngrams.size();
			// Iterate ngram hashmap to calculate conditional probabilities for
			// each ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of apps for each classes that owns the
				// given ngram
				Double[] condProbs = new Double[numberOfClass];

				Short[] values = entry.getValue();

				for (int i = 0; i < numberOfClass; i++)
					condProbs[i] = (((double) values[i] + 1.0) / ((double) ngramCountPerClass[i] + (double) vocabularySize));

				ngramsWithCondProbs.put(entry.getKey(), condProbs);

			}

			FileUtils.write(ngramsCondProbFile, "NGRAM" + Constants.TAB_CHAR
					+ "CONDITIONAL PROBABILITES", true);

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {
				FileUtils
						.write(ngramsCondProbFile, "\n" + entry.getKey(), true);

				for (int i = 0; i < numberOfClass; i++) {
					FileUtils.write(ngramsCondProbFile, Constants.TAB_CHAR
							+ entry.getValue()[i], true);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> readCondProbsOfNgramsFromFile(
			String filePath) {

		File ngramsCondProbFile = new File(filePath);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {
			List<String> lines = FileUtils.readLines(ngramsCondProbFile);
			int lineNumber = 0;
			for (String line : lines) {
				lineNumber++;
				// Skip header line
				if (line != null && !line.equals("") && lineNumber != 1) {
					String[] tokens = line.split(Constants.TAB_CHAR);
					Double[] probs = new Double[tokens.length - 1];
					for (int i = 0; i < probs.length; i++)
						probs[i] = Double.valueOf(tokens[i + 1]);
					ngramsWithCondProbs.put(tokens[0], probs);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> extractDistinctiveNgramsByCondProbs(
			HashMap<String, Double[]> ngramsWithCondProbs, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_cond_probs.tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);

		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		int topRankedSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
		// This structure will keep the top-ranked ngrams with their information
		// gain

		ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
		ScorePair[] topRankedNgramsForClassA = new ScorePair[topRankedSize / 2];
		ScorePair[] topRankedNgramsForClassB = new ScorePair[topRankedSize / 2];

		try {
			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgramsForClassA.length; i++) {
				topRankedNgramsForClassA[i] = new ScorePair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new ScorePair(
						Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {

				double dif = (entry.getValue()[0] - entry.getValue()[1])
						/ (entry.getValue()[0] + entry.getValue()[1]);
				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				if (dif > 0.0) {
					double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);

					if (entry.getValue()[0] > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new ScorePair(
								entry.getKey(), dif);
					}
				} else if (dif < 0.0) {
					double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);
					if (entry.getValue()[1] > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new ScorePair(
								entry.getKey(), Math.abs(dif));
					}
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgramsForClassA);
			Arrays.sort(topRankedNgramsForClassB);
			int index = 0;
			int indexClass = 0;
			while (index < topRankedNgrams.length) {
				topRankedNgrams[index] = topRankedNgramsForClassA[indexClass];
				topRankedNgrams[++index] = topRankedNgramsForClassB[indexClass];
				index++;
				indexClass++;
			}
			if (extension.equals(Constants.SMALI_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
					|| extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION)
					|| extension
							.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION)) {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Information Gain"
						+ Constants.TAB_CHAR + "Class" + Constants.TAB_CHAR
						+ "Text" + "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Information Gain"
						+ Constants.TAB_CHAR + "Class" + Constants.TAB_CHAR
						+ "Text" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1)
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey()
							+ Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue()
							+ Constants.TAB_CHAR
							+ (((i % 2) == 0) ? Constants.CLASS_A_NAME
									: Constants.CLASS_B_NAME)
							+ Constants.TAB_CHAR
							+ new String(
									DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
									"").replace("\t", "") + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1)
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue()
									+ Constants.TAB_CHAR
									+ (((i % 2) == 0) ? Constants.CLASS_A_NAME
											: Constants.CLASS_B_NAME)
									+ Constants.TAB_CHAR
									+ new String(DatatypeConverter
											.parseHexBinary(topRankedNgrams[i]
													.getKey())).replace("\n",
											"").replace("\t", "") + "\n", true);
				}
			} else {
				FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
						+ "Ngram" + Constants.TAB_CHAR + "Information Gain"
						+ "\n", true);
				System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
						+ Constants.TAB_CHAR + "Information Gain" + "\n");
				for (int i = 0; i < topRankedNgrams.length; i++) {
					System.out.print((i + 1) + Constants.TAB_CHAR
							+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
							+ topRankedNgrams[i].getValue() + "\n");
					FileUtils.write(
							rankedNgramsFile,
							(i + 1) + Constants.TAB_CHAR
									+ topRankedNgrams[i].getKey()
									+ Constants.TAB_CHAR
									+ topRankedNgrams[i].getValue() + "\n",
							true);
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> extractDistinctiveNgramsByCondProbsFile(
			String filePath, String extension) {
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		// Top-ranked ngram features file name generation
		String rankedNgramsPath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG)
				+ (extension + Constants.UNDERSCORE + "distinctive_"
						+ ngramSize + "-grams_by_cond_probs.tsv").toLowerCase();
		File rankedNgramsFile = new File(rankedNgramsPath);

		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = readCondProbsOfNgramsFromFile(filePath);
		int topRankedSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.TOP_RANKED_SIZE_CONFIG));
		// This structure will keep the top-ranked ngrams with their information
		// gain

		ScorePair[] topRankedNgrams = new ScorePair[topRankedSize];
		ScorePair[] topRankedNgramsForClassA = new ScorePair[topRankedSize / 2];
		ScorePair[] topRankedNgramsForClassB = new ScorePair[topRankedSize / 2];

		try {
			// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgramsForClassA.length; i++) {
				topRankedNgramsForClassA[i] = new ScorePair(
						Integer.toString(i), 0.0);
				topRankedNgramsForClassB[i] = new ScorePair(
						Integer.toString(i), 0.0);
			}

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {

				double dif = (entry.getValue()[0] - entry.getValue()[1])
						/ (entry.getValue()[0] + entry.getValue()[1]);
				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				if (dif > 0.0) {
					double[] minIGA = minIndexAndValue(topRankedNgramsForClassA);

					if (entry.getValue()[0] > minIGA[1]) {
						topRankedNgramsForClassA[(int) minIGA[0]] = new ScorePair(
								entry.getKey(), dif);
					}
				} else if (dif < 0.0) {
					double[] minIGB = minIndexAndValue(topRankedNgramsForClassB);
					if (entry.getValue()[1] > minIGB[1]) {
						topRankedNgramsForClassB[(int) minIGB[0]] = new ScorePair(
								entry.getKey(), Math.abs(dif));
					}
				}
			}
			// Sort top ranked array and print it to file and console
			topRankedNgrams = ArrayUtils.addAll(topRankedNgramsForClassA,
					topRankedNgramsForClassB);
			Arrays.sort(topRankedNgrams);

			FileUtils.write(rankedNgramsFile, "Rank" + Constants.TAB_CHAR
					+ "Ngram" + Constants.TAB_CHAR + "Class Difference" + "\n",
					true);
			System.out.print("Rank" + Constants.TAB_CHAR + "Ngram"
					+ Constants.TAB_CHAR + "Class Difference" + "\n");
			for (int i = 0; i < topRankedNgrams.length; i++) {
				System.out.print((i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n");
				FileUtils.write(rankedNgramsFile, (i + 1) + Constants.TAB_CHAR
						+ topRankedNgrams[i].getKey() + Constants.TAB_CHAR
						+ topRankedNgrams[i].getValue() + "\n", true);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static ArrayList<HashSet<String>> readDistinctiveNgramsFromFiles(
			String filePattern, ArrayList<Integer> inputSizes)
			throws IOException {
		ArrayList<HashSet<String>> rankedNgramsSets = new ArrayList<HashSet<String>>();
		File dir = new File(
				FileHandler.readConfigValue(Constants.REPORTS_PATH_CONFIG));
		File[] matchingFiles = dir.listFiles(new FilenameFilter() {
			public boolean accept(File dir, String name) {
				return name.startsWith(filePattern) && name.endsWith(".tsv");
			}
		});
		File fileIndexes = new File(
				FileHandler.readConfigValue(Constants.REPORTS_PATH_CONFIG)
						+ File.separator + "ngrams_distinctive_files_list.txt");
		FileUtils.write(fileIndexes, "pattern:" + filePattern + "\n", true);
		for (int k = 0; k < matchingFiles.length; k++) {
			FileUtils.write(fileIndexes, k + ":" + matchingFiles[k].getName()
					+ "\n", true);
			for (int j = 0; j < inputSizes.size(); j++) {
				HashSet<String> topRankedNgrams = new HashSet<String>();
				List<String> fileLines = FileUtils.readLines(matchingFiles[k]);
				for (int i = 1; i <= inputSizes.get(j); i++) {
					String[] values = fileLines.get(i)
							.split(Constants.TAB_CHAR);
					topRankedNgrams.add(values[1]);
				}
				rankedNgramsSets.add(topRankedNgrams);
			}
		}
		return rankedNgramsSets;
	}

	public static void generateDistinctiveNgramsFiles(String dataPath,
			String extension, boolean isTestData) {
		HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension,
				isTestData);
		extractDistinctiveNgramsByNormalizedAngle(ngrams, extension);
		extractDistinctiveNgramsByIG(ngrams, extension);
		extractDistinctiveNgramsByClasswiseIG(ngrams, extension);
		// if (!extension.equals(Constants.DEX_EXTENSION)
		// && !extension.equals(Constants.CLASS_EXTENSION))
		// extractDistinctiveNgramsByCondProbs(
		// calculateCondProbsOfNgrams(ngrams, extension), extension);
	}

	public static String prepareWekaFileHeader(HashSet<String> topRankedNgrams,
			String extension, boolean isTestData, int numberOfDataInput,
			String extractionMethodology) throws IOException {
		// Data class label for reports and input files
		int ngramSize = Integer.parseInt(FileHandler
				.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

		String trainOrTestLabel = isTestData ? Constants.TEST_LABEL
				: Constants.TRAIN_LABEL;

		// Generate data file and prepare it with its headers
		String wekaDataFilePath = FileHandler
				.readConfigValue(Constants.REPORTS_PATH_CONFIG) +
				trainOrTestLabel + File.separator
				+ (trainOrTestLabel + Constants.UNDERSCORE + extension
						+ Constants.UNDERSCORE + ngramSize + "-grams"
						+ Constants.UNDERSCORE + numberOfDataInput
						+ Constants.UNDERSCORE + extractionMethodology + ".arff")
						.toLowerCase();

		File wekaDataFile = new File(wekaDataFilePath);
		FileUtils.deleteQuietly(wekaDataFile);

		FileUtils
				.write(wekaDataFile,
						"%%%\n"
								+ "% This "
								+ trainOrTestLabel.toLowerCase()
								+ " data file consists of the most distictive ngrams extracted\n"
								+ "% from reversed engineered *."
								+ extension
								+ " files of known Android apps\n"
								+ "% to classify unknown Anroid apps as "
								+ Constants.CLASS_A_NAME.toLowerCase()
								+ " or "
								+ Constants.CLASS_B_NAME.toLowerCase()
								+ " application\n"
								+ "% by using Weka classifier algorithms. The study is being conducted\n"
								+ "% by Munir Geden and Jens Krinke as part of a research in UCL.\n"
								+ "%\n" + "@relation 'ngram'\n", true);

		FileUtils.write(wekaDataFile, "@attribute appname string\n", true);
		for (String entry : topRankedNgrams) {
			FileUtils.write(wekaDataFile, "@attribute " + entry + " numeric\n",
					true);
		}

		FileUtils.write(wekaDataFile,
				"@attribute class {" + Constants.CLASS_A_NAME + ","
						+ Constants.CLASS_B_NAME + "}\n", true);
		FileUtils.write(wekaDataFile, "@data\n", true);
		return wekaDataFilePath;
	}

	public static void prepareWekaFileDataPerApp(
			ArrayList<HashSet<String>> topRankedNgramsListSet, String appPath,
			ArrayList<String> dataFilePaths, String extension,
			boolean isTestData) {

		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

			// Arff file that will keep training data values
			ArrayList<File> dataFiles = new ArrayList<File>();
			for (String s : dataFilePaths)
				dataFiles.add(new File(s));

			// Collect all files under the path of given app
			Collection<File> files = FileHandler.findFiles(appPath,
					new String[] { extension });

			ArrayList<HashMap<String, Integer>> calculatedDatas = new ArrayList<HashMap<String, Integer>>();
			for (HashSet<String> rankedList : topRankedNgramsListSet) {
				HashMap<String, Integer> calculatedData = new HashMap<String, Integer>();
				for (String entry : rankedList) {
					calculatedData.put(entry, 0);
				}
				calculatedDatas.add(calculatedData);
			}
			// Retrieve class type, its name and its integer array index from
			// file path
			boolean taxon = appPath.contains(File.separator
					+ Constants.CLASS_A_NAME + File.separator);
			String className = taxon ? Constants.CLASS_A_NAME
					: Constants.CLASS_B_NAME;

			// Find appName from path
			String appName = appNameOfFile(appPath, extension);

			// Print iteration information for console
			System.out.print("Analysing app... Class:" + className
					+ Constants.TAB_CHAR + "Extension:" + extension
					+ Constants.TAB_CHAR + "App Name:" + appName + "\n");

			// Number of files traversed
			int fileIterator = -1;

			// Performance monitor watch
			StopWatch watch = new StopWatch();
			watch.reset();
			watch.start();

			// Traverse app files to be analyzed
			for (File file : files) {
				fileIterator++;

				// Read files as byte array and convert them to hexadecimal
				// strings
				byte fileHex[];
				if (extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)
						|| extension
								.equals(Constants.BERTILLONAGE_DEX_EXTENSION)) {
					fileHex = FileHandler
							.readFileToString(file.getAbsolutePath())
							.replaceAll("H:    [A-Za-z0-9]{32}", "").getBytes();

				} else {
					fileHex = FileHandler.readFileToByteArray(file
							.getAbsolutePath());
				}
				for (int i = 0; i < fileHex.length - (ngramSize - 1); i++) {
					StringBuilder sb = new StringBuilder();
					for (int j = 0; j < ngramSize; j++) {
						// if (fileHex[i + j] != 0)
						sb.append(String.format("%02X", fileHex[i + j]));

					}
					String ngram = sb.toString();
					for (int k = 0; k < topRankedNgramsListSet.size(); k++) {
						if (topRankedNgramsListSet.get(k).contains(ngram)) {
							if (calculatedDatas.get(k).containsKey(ngram)) {
								calculatedDatas.get(k).put(ngram, 1);
							}
						}
					}
				}
			}

			watch.stop();
			// Print the time elapsed to analyze the app.
			System.out.print("Completed... Elapsed Time:"
					+ (double) watch.getTime() / 1000.0 + " secs."
					+ Constants.TAB_CHAR + "Number of Files:"
					+ (fileIterator + 1) + "\n");

			for (int k = 0; k < topRankedNgramsListSet.size(); k++) {

				// Append app inputs to arff file
				FileUtils.write(dataFiles.get(k), appName + ",", true);
				for (Map.Entry<String, Integer> entry : calculatedDatas.get(k)
						.entrySet()) {
					FileUtils.write(dataFiles.get(k), entry.getValue() + ",",
							true);
				}
				FileUtils.write(dataFiles.get(k), className + "\n", true);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public static void prepareWekaFiles(String filePattern, String dataPath,
			String extension, boolean isTestData, ArrayList<Integer> inputSizes) {
		try {
			ArrayList<HashSet<String>> rankedNgramsSets = readDistinctiveNgramsFromFiles(
					filePattern, inputSizes);
			ArrayList<String> dataFilePaths = new ArrayList<String>();
			for (int i = 0; i < rankedNgramsSets.size(); i++) {
				HashSet<String> topRankedNgrams = rankedNgramsSets.get(i);
				String dataFilePath = prepareWekaFileHeader(topRankedNgrams,
						extension, isTestData,
						inputSizes.get(i % inputSizes.size()),
						Integer.toString(i / inputSizes.size()));
				dataFilePaths.add(dataFilePath);
			}
			String[] appPaths = appPathsOfGivenClass(dataPath, extension,
					isTestData);
			for (String appPath : appPaths) {
				prepareWekaFileDataPerApp(rankedNgramsSets, appPath,
						dataFilePaths, extension, isTestData);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	private static String[] appPathsOfGivenClass(String dataPath,
			String extension, boolean isTestData) {
		String dataTypeFolder = "";
		if (!(dataPath.contains(File.separator + Constants.TEST_LABEL
				+ File.separator) || dataPath.contains(File.separator
				+ Constants.TRAIN_LABEL + File.separator))) {
			dataTypeFolder = isTestData ? Constants.TEST_LABEL
					: Constants.TRAIN_LABEL;
		}
		String classPathA = dataPath + File.separator + dataTypeFolder
				+ File.separator + Constants.CLASS_A_NAME + File.separator
				+ extension.toUpperCase() + File.separator;
		String classPathB = dataPath + File.separator + dataTypeFolder
				+ File.separator + Constants.CLASS_B_NAME + File.separator
				+ extension.toUpperCase() + File.separator;
		String[] appPaths = ArrayUtils.addAll(
				FileHandler.findFolderContents(classPathA),
				FileHandler.findFolderContents(classPathB));
		return appPaths;
	}

	private static String appNameOfFile(String appPath, String extension) {
		// Retrieve app name from file path
		if (appPath.contains(Constants.UNDERSCORE + extension.toUpperCase())) {
			String[] folders = appPath.substring(
					0,
					appPath.lastIndexOf(Constants.UNDERSCORE
							+ extension.toUpperCase())).split(File.separator);
			return folders[folders.length - 1];
		} else {
			String[] folders = appPath.split(File.separator);
			return folders[folders.length - 1];
		}

	}

	private static double[] minIndexAndValue(ScorePair[] arr) {
		double minValue = Double.MAX_VALUE;
		int minIndex = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getValue() < minValue) {
				minValue = arr[i].getValue();
				minIndex = i;
			}
		}
		return new double[] { (double) minIndex, minValue };
	}

	private static double[] maxIndexAndValue(ScorePair[] arr) {
		double maxValue = 0.0;
		int maxIndex = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getValue() > maxValue) {
				maxValue = arr[i].getValue();
				maxIndex = i;
			}
		}
		return new double[] { (double) maxIndex, maxValue };
	}

	public static int randWithinRange(int min, int max) {
		Random rand = new Random();
		int numValue = rand.nextInt((max - min) + 1) + min;
		return numValue;
	}

}

class ScorePair implements Comparable<ScorePair> {

	private String key;
	private double value;

	public ScorePair(String key, double value) {
		this.key = key;
		this.value = value;
	}

	/**
	 * @return the key
	 */
	public String getKey() {
		return key;
	}

	/**
	 * @param key
	 *            the key to set
	 */
	public void setKey(String key) {
		this.key = key;
	}

	/**
	 * @return the value
	 */
	public double getValue() {
		return value;
	}

	/**
	 * @param value
	 *            the value to set
	 */
	public void setValue(double value) {
		this.value = value;
	}

	@Override
	public int compareTo(ScorePair item) {
		if (this.value < item.value) {
			return 1;
		} else if (this.value > item.value) {
			return -1;
		} else {
			return 0;
		}
	}
}