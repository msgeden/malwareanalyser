/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.util.*;
import java.io.File;
import java.io.IOException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.StopWatch;

/**
 *
 * @author msgeden
 */
public class NgramExtractor {

    public static HashMap<String, Short[]> constructNgramsPerApp(HashMap<String, Short[]> cumulativeNgrams, String appPath, String extension, boolean isTestData, File reportFile) {

        try {
            //Collect all files under the path of given app
            Collection<File> files = FileHandler.findFiles(appPath, new String[]{extension});

            //This will keep the information whether given app owns ngrams
            HashSet<String> ngrams = new HashSet<String>();

            //Retrieve class type, its name and its integer array index from file path
            boolean taxon = appPath.contains(File.separator + Constants.CLASS_A_NAME + File.separator);
            String className = taxon ? Constants.CLASS_A_NAME : Constants.CLASS_B_NAME;
            int classFrequencyIndex = taxon ? 0 : 1;

            //Retrieve app name from file path
            String[] folders = appPath.split(File.separator);
            String appName = folders[folders.length - 1];
            //Number of files traversed
            int fileIterator = -1;

            //Performance monitor watch
            StopWatch watch = new StopWatch();
            watch.reset();
            watch.start();

            //Traverse app files to be analyzed
            for (File file : files) {
                fileIterator++;

                //Read files as byte array and convert them to hexadecimal strings by eliminating zero bytes
                byte[] fileHex = FileHandler.readFileToByteArray(file.getAbsolutePath());
                for (int i = 0; i < fileHex.length - Constants.NGRAM_SIZE * 2; i++) {
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < Constants.NGRAM_SIZE; j++) {
                        //if (fileHex[i + j] != 0) 
                        sb.append(String.format("%02X", fileHex[i + j]));

                    }
                    String ngram = sb.toString();
                    ngrams.add(ngram);
                }
            }
            //Merge app ngram set with cumulative ngram hashmap
            for (String ngram : ngrams) {
                if (cumulativeNgrams.containsKey(ngram)) {
                    Short[] classFrequencies = cumulativeNgrams.get(ngram);
                    classFrequencies[classFrequencyIndex] = (short) (classFrequencies[classFrequencyIndex] + 1);
                    cumulativeNgrams.put(ngram, classFrequencies);
                } else {
                    Short[] classFrequencies = new Short[]{0, 0};
                    classFrequencies[classFrequencyIndex] = 1;
                    cumulativeNgrams.put(ngram, classFrequencies);
                }
            }

            //These values are stored in ngrams hashmap not to iterate once more during the information gain calculation
            if (cumulativeNgrams.containsKey(Constants.COUNT_OF_APPS_PER_CLASS)) {
                Short[] appCountsForClasses = cumulativeNgrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
                appCountsForClasses[classFrequencyIndex] = (short) (appCountsForClasses[classFrequencyIndex] + 1);
                cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS, appCountsForClasses);
            } else {
                Short[] appCountsForClasses = new Short[]{0, 0};
                appCountsForClasses[classFrequencyIndex] = 1;
                cumulativeNgrams.put(Constants.COUNT_OF_APPS_PER_CLASS, appCountsForClasses);
            }

            //Print the number of unique ngrams, files are processed.
            //Print the number of unique ngrams, files are processed.
            FileUtils.write(reportFile, className
                    + Constants.TAB_CHAR + extension
                    + Constants.TAB_CHAR + ngrams.size()
                    + Constants.TAB_CHAR + cumulativeNgrams.size()
                    + Constants.TAB_CHAR + (fileIterator + 1)
                    + Constants.TAB_CHAR + (double) watch.getTime() / 1000.0
                    + Constants.TAB_CHAR + appName
                    + "\n", true);
            System.out.print(className
                    + Constants.TAB_CHAR + extension
                    + Constants.TAB_CHAR + ngrams.size()
                    + Constants.TAB_CHAR + cumulativeNgrams.size()
                    + Constants.TAB_CHAR + (fileIterator + 1)
                    + Constants.TAB_CHAR + (double) watch.getTime() / 1000.0
                    + Constants.TAB_CHAR + appName
                    + "\n");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return cumulativeNgrams;
    }
    public static HashMap<String, Short[]> constructNgrams(String dataPath, String extension, boolean isTestData) {

        HashMap<String, Short[]> ngrams = new HashMap<String, Short[]>();
        try {
            String[] appPaths = appPathsOfGivenClass(dataPath, extension, isTestData);

            //Data class label for reports and input files
            String trainOrTestLabel = isTestData ? Constants.TEST_LABEL : Constants.TRAIN_LABEL;

            //Generate report file name
            String reportFilePath = (Constants.REPORTS_PATH
                    + trainOrTestLabel
                    + Constants.UNDERSCORE + extension
                    + Constants.UNDERSCORE + "ngram"
                    + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                    + Constants.UNDERSCORE + "report.tsv").toLowerCase();

            File reportFile = new File(reportFilePath);
            FileUtils.deleteQuietly(reportFile);
            FileUtils.write(reportFile, "Class"
                    + Constants.TAB_CHAR + "Extension"
                    + Constants.TAB_CHAR + "# of Ngrams"
                    + Constants.TAB_CHAR + "# of Total Ngrams"
                    + Constants.TAB_CHAR + "Number of Files"
                    + Constants.TAB_CHAR + "Time Elapsed"
                    + Constants.TAB_CHAR + "App Name"
                    + Constants.TAB_CHAR + "\n", true);
            System.out.print("Number"
                    + Constants.TAB_CHAR + "Class"
                    + Constants.TAB_CHAR + "Extension"
                    + Constants.TAB_CHAR + "# of Ngrams"
                    + Constants.TAB_CHAR + "# of Total Ngrams"
                    + Constants.TAB_CHAR + "Number of Files"
                    + Constants.TAB_CHAR + "Time Elapsed"
                    + Constants.TAB_CHAR + "App Name"
                    + Constants.TAB_CHAR + "\n");
            int count = 0;
            for (String appPath : appPaths) {
                System.out.print((++count) + Constants.TAB_CHAR);
                ngrams = constructNgramsPerApp(ngrams, appPath, extension, isTestData, reportFile);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ngrams;
    }
    public static String extractIGOfNgrams(HashMap<String, Short[]> ngrams, String extension) {

        //Top-ranked ngram features file name generation
        String randomNgramsPath = (Constants.REPORTS_PATH
                + extension
                + Constants.UNDERSCORE + "random_ngrams_ig"
                + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                + ".tsv").toLowerCase();
        File randomNgramsFile = new File(randomNgramsPath);

        String rankedNgramsPath = (Constants.REPORTS_PATH
                + extension
                + Constants.UNDERSCORE + "topranked_ngrams_ig"
                + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                + ".tsv").toLowerCase();
        File rankedNgramsFile = new File(rankedNgramsPath);
        StopWatch watch = new StopWatch();
        watch.reset();
        watch.start();

        //Try to delete if it exists without exception
        FileUtils.deleteQuietly(randomNgramsFile);
        FileUtils.deleteQuietly(rankedNgramsFile);

        try {

            //This will keep the information gain extracted from each ngram
            HashMap<String, Double> ngramsWithIG = new HashMap<String, Double>();

            //This structure will keep the top-ranked ngrams with their information gain
            NGramIGPair[] topRankedNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];
            //This structure is defined to validate the distribution of information gain scores
            NGramIGPair[] randomNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];

            //Retrieve the number of apps per class from the specific entry
            Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
            double totalNumberOfAppsInClassA = (double) countApps[0];//10
            double totalNumberOfAppsInClassB = (double) countApps[1];//10
            double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

            //Remove this specific entry not to interpret as ngram
            //ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

            //Iterate ngram hashmap to calculate information gain for each ngram
            for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

                //Calculate the number of apps for each classes that owns the given ngram
                Short[] values = entry.getValue();

                //Terms that are needed for information gain calculation
                double numberOfAppsHoldNgramInClassA = (double) values[0];
                double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
                double numberOfAppsHoldNgramInClassB = (double) values[1];
                double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

                //Calculation formula of information gain: For details see the paper of Kolter et. al and Reddy et. al.
                double[] informationGainForNgram = new double[4];
                informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
                        * Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
                                / (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
                        * Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
                                / (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
                        * Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
                                / (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
                        * Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
                                / (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                //Skip infinite and NaN terms
                double informationGainForNgramTotal = 0.0;
                for (int i = 0; i < informationGainForNgram.length; i++) {
                    if (!(Double.isNaN(informationGainForNgram[i]) || !Double.isFinite(informationGainForNgram[i]))) {
                        informationGainForNgramTotal += informationGainForNgram[i];
                    }
                }
                //Add calculated information gain for the given ngram
                ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
            }

            //Initialize top-ranked array values for ordering and comparison
            for (int i = 0; i < topRankedNgrams.length; i++) {
                topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
                randomNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
            }

            for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

                //Find the first minimum value and its index in top-ranked array to replace-> index0:index of the item, index 1-> value of item
                double[] minIG = minIndexAndValue(topRankedNgrams);
                if (entry.getValue() > minIG[1]) {
                    topRankedNgrams[(int) minIG[0]] = new NGramIGPair(entry.getKey(), entry.getValue());
                }

                //If there is positive number add this value to the array with random index to validate distribution
                if (entry.getValue() > 0.0) {
                    randomNgrams[randWithinRange(0, Constants.TOP_RANKED_SIZE - 1)] = new NGramIGPair(entry.getKey(), entry.getValue());
                }
            }
            //Sort top ranked array and print it to file and console
            Arrays.sort(topRankedNgrams);
            FileUtils.write(rankedNgramsFile, "Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n");
            for (int i = 0; i < topRankedNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n");
                FileUtils.write(rankedNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n", true);
            }
            //Print random array to file and console without sorting
            FileUtils.write(randomNgramsFile, "Line"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n");

            for (int i = 0; i < randomNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n");
                FileUtils.write(randomNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n", true);
            }
            watch.stop();
            //Print the time elapsed to analyze the app.
            System.out.println("Analysing Information Gains... Elapsed Time:" + (double) watch.getTime() / 1000.0 + " secs." + "\n");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return rankedNgramsFile.getAbsolutePath();
    }

    public static String extractEntropyOfNgrams(HashMap<String, Short[]> ngrams, String extension) {

        //Top-ranked ngram features file name generation
        String randomNgramsPath = (Constants.REPORTS_PATH
                + extension
                + Constants.UNDERSCORE + "random_ngrams_entropy"
                + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                + ".tsv").toLowerCase();
        File randomNgramsFile = new File(randomNgramsPath);

        String rankedNgramsPath = (Constants.REPORTS_PATH
                + extension
                + Constants.UNDERSCORE + "topranked_ngrams_entropy"
                + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                + ".tsv").toLowerCase();
        File rankedNgramsFile = new File(rankedNgramsPath);
        StopWatch watch = new StopWatch();
        watch.reset();
        watch.start();

        //Try to delete if it exists without exception
        FileUtils.deleteQuietly(randomNgramsFile);
        FileUtils.deleteQuietly(rankedNgramsFile);

        try {

            //This will keep the information gain extracted from each ngram
            HashMap<String, Double> ngramsWithEntropy = new HashMap<String, Double>();

            //This structure will keep the top-ranked ngrams with their information gain
            NGramIGPair[] topRankedNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];
            //This structure is defined to validate the distribution of information gain scores
            NGramIGPair[] randomNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];

            //Retrieve the number of apps per class from the specific entry
            Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
            //Remove this specific entry not to interpret as ngram
            //ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

            //Iterate ngram hashmap to calculate information gain for each ngram
            for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

                //Calculate the number of apps for each classes that owns the given ngram
                Short[] values = entry.getValue();

             	int sum = 0;
				for (int i = 0; i < values.length; i++)
					sum += values[i];
				double entropy = 0.0;
				for (int i = 0; i < countApps.length; i++) {

					double p = (double) values[i] / (double) sum;
					if (p == 0.0 || p == 1.0)
						continue;
					entropy += (p * (Math.log(p) / Math.log(2.0)));
				}
				entropy = -1 * entropy;
				// Add calculated entropy for the given ngram
				if (entropy > 0.0)
					ngramsWithEntropy.put(entry.getKey(), entropy);
				else
					ngramsWithEntropy.put(entry.getKey(), 1.0);
            }
    		// Initialize top-ranked array values for ordering and comparison
			for (int i = 0; i < topRankedNgrams.length; i++) {
				topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 1.0);
				randomNgrams[i] = new NGramIGPair(Integer.toString(i), 1.0);
			}

			for (Map.Entry<String, Double> entry : ngramsWithEntropy.entrySet()) {

				// Find the first minimum value and its index in top-ranked
				// array to replace-> index0:index of the item, index 1-> value
				// of item
				double[] maxIG = maxIndexAndValue(topRankedNgrams);
				if (entry.getValue() < maxIG[1]) {
					topRankedNgrams[(int) maxIG[0]] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}

				// If there is positive number add this value to the array with
				// random index to validate distribution
				if (entry.getValue() < 1.0) {
					randomNgrams[randWithinRange(0,
							Constants.TOP_RANKED_SIZE - 1)] = new NGramIGPair(
							entry.getKey(), entry.getValue());
				}
			}
			// Sort top ranked array and print it to file and console
			Arrays.sort(topRankedNgrams, Collections.reverseOrder());        
			FileUtils.write(rankedNgramsFile, "Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Entropy"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Entropy"
                    + "\n");
            for (int i = 0; i < topRankedNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n");
                FileUtils.write(rankedNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n", true);
            }
            //Print random array to file and console without sorting
            FileUtils.write(randomNgramsFile, "Line"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Entropy"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Entropy"
                    + "\n");

            for (int i = 0; i < randomNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n");
                FileUtils.write(randomNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n", true);
            }
            watch.stop();
            //Print the time elapsed to analyze the app.
            System.out.println("Analysing Entropies... Elapsed Time:" + (double) watch.getTime() / 1000.0 + " secs." + "\n");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return rankedNgramsFile.getAbsolutePath();
    }
    
    public static String extractSalienceOfNgrams(HashMap<String, Short[]> ngrams, String extension) {

        //Top-ranked ngram features file name generation
        String randomNgramsPath = (Constants.REPORTS_PATH
                + extension
                + Constants.UNDERSCORE + "random_ngrams_salience"
                + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                + ".tsv").toLowerCase();
        File randomNgramsFile = new File(randomNgramsPath);

        String rankedNgramsPath = (Constants.REPORTS_PATH
                + extension
                + Constants.UNDERSCORE + "topranked_ngrams_salience"
                + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                + ".tsv").toLowerCase();
        File rankedNgramsFile = new File(rankedNgramsPath);
        StopWatch watch = new StopWatch();
        watch.reset();
        watch.start();

        //Try to delete if it exists without exception
        FileUtils.deleteQuietly(randomNgramsFile);
        FileUtils.deleteQuietly(rankedNgramsFile);

        try {

            //This will keep the information gain extracted from each ngram
            HashMap<String, Double> ngramsWithSalience = new HashMap<String, Double>();

            //This structure will keep the top-ranked ngrams with their information gain
            NGramIGPair[] topRankedNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];
            //This structure is defined to validate the distribution of information gain scores
            NGramIGPair[] randomNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];

            //Retrieve the number of apps per class from the specific entry
            Short[] countApps = ngrams.get(Constants.COUNT_OF_APPS_PER_CLASS);
            double threshold = Constants.SALIENCE_THRESHOLD;
            
            //Remove this specific entry not to interpret as ngram
            //ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

            //Iterate ngram hashmap to calculate information gain for each ngram
            for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

                //Calculate the number of apps for each classes that owns the given ngram
                Short[] values = entry.getValue();

                //Terms that are needed for information gain calculation
    			int N = values.length;
				double salience = 0.0;
				for (int i = 0; i < N - 1; i++) {
					double p_g_si = (double) values[i]
							/ (double) countApps[i];
					for (int j = i + 1; j < N; j++) {
						double p_g_sj = (double) values[j]
								/ (double) countApps[j];
						double denom = (Double.min(p_g_si, p_g_sj) / Double
								.max(p_g_si, p_g_sj));
						if (Double.isNaN(denom))
							denom = 0.0;
						salience += (1 - denom);
					}
				}
				salience /= N;
				// Add calculated salience for the given ngram
				if (salience > threshold && salience < 1.0)
					ngramsWithSalience.put(entry.getKey(), salience);
            }

            //Initialize top-ranked array values for ordering and comparison
            for (int i = 0; i < topRankedNgrams.length; i++) {
                topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
                randomNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
            }

            for (Map.Entry<String, Double> entry : ngramsWithSalience.entrySet()) {

                //Find the first minimum value and its index in top-ranked array to replace-> index0:index of the item, index 1-> value of item
                double[] minIG = minIndexAndValue(topRankedNgrams);
                if (entry.getValue() > minIG[1]) {
                    topRankedNgrams[(int) minIG[0]] = new NGramIGPair(entry.getKey(), entry.getValue());
                }

                //If there is positive number add this value to the array with random index to validate distribution
                if (entry.getValue() > 0.0) {
                    randomNgrams[randWithinRange(0, Constants.TOP_RANKED_SIZE - 1)] = new NGramIGPair(entry.getKey(), entry.getValue());
                }
            }
            //Sort top ranked array and print it to file and console
            Arrays.sort(topRankedNgrams);
            FileUtils.write(rankedNgramsFile, "Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Salience"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Salience"
                    + "\n");
            for (int i = 0; i < topRankedNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n");
                FileUtils.write(rankedNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n", true);
            }
            //Print random array to file and console without sorting
            FileUtils.write(randomNgramsFile, "Line"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Salience"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Salience"
                    + "\n");

            for (int i = 0; i < randomNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n");
                FileUtils.write(randomNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n", true);
            }
            watch.stop();
            //Print the time elapsed to analyze the app.
            System.out.println("Analysing Saliences... Elapsed Time:" + (double) watch.getTime() / 1000.0 + " secs." + "\n");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return rankedNgramsFile.getAbsolutePath();
    }

	public static HashMap<String, Double[]> calculateCondProbsOfNgrams(
			HashMap<String, Short[]> ngrams) {
		//int ngramSize = Integer.parseInt(FileHandler.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
		String ngramsCondProbPath = (Constants.REPORTS_PATH
				+ "condprob_ngrams"
				+ Constants.UNDERSCORE
				+ Constants.NGRAM_SIZE + ".tsv").toLowerCase();
		File ngramsCondProbFile = new File(ngramsCondProbPath);

		// Try to delete if it exists without exception
		FileUtils.deleteQuietly(ngramsCondProbFile);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|S_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {

			// Retrieve the number of tweets for each class
			Short[] appCountPerClass = ngrams
					.get(Constants.COUNT_OF_APPS_PER_CLASS);

			int numberOfClass = appCountPerClass.length;

			double[] totalNumberOfAppsInClass = new double[appCountPerClass.length];
			double totalNumberOfApps = 0.0;
			for (int i = 0; i < appCountPerClass.length; i++) {
				totalNumberOfAppsInClass[i] = (double) appCountPerClass[i];
				totalNumberOfApps += totalNumberOfAppsInClass[i];
			}
			// Calculate prior probability for each class: P(S_i)
			Double[] priors = new Double[numberOfClass];
			for (int i = 0; i < priors.length; i++)
				priors[i] = totalNumberOfAppsInClass[i] / totalNumberOfApps;

			ngramsWithCondProbs.put(Constants.PRIOR_PER_CLASS, priors);

			// Retrieve the number of ngrams for each class
			Integer[] ngramCountPerClass = new Integer[]{0,0};
			
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {
				ngramCountPerClass[0] += entry.getValue()[0];
				ngramCountPerClass[1] += entry.getValue()[1];
			}
			int vocabularySize = ngrams.size();
			// Iterate ngram hashmap to calculate conditional probabilities for
			// each ngram
			for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

				// Calculate the number of tweets for each classes that owns the
				// given ngram
				Double[] condProbs = new Double[numberOfClass];

				Short[] values = entry.getValue();

				for (int i = 0; i < numberOfClass; i++)
					condProbs[i] = (((double)values[i] + 1.0) / ((double)ngramCountPerClass[i] + (double)vocabularySize));

				ngramsWithCondProbs.put(entry.getKey(), condProbs);

			}

			FileUtils.write(ngramsCondProbFile,  "NGRAM" + Constants.TAB_CHAR 
					+ "CONDITIONAL PROBABILITES", true);
//			System.out.print("COUNT" + Constants.TAB_CHAR 
//					+ "P(NGRAM|CLASS)" + Constants.TAB_CHAR 
//					+ "CONDITIONAL PROBABILITES");

			int count = 0;

			for (Map.Entry<String, Double[]> entry : ngramsWithCondProbs
					.entrySet()) {
				FileUtils.write(
						ngramsCondProbFile,
						"\n" + entry.getKey(), 
						true);
			
				for (int i = 0; i < numberOfClass; i++) {
					FileUtils.write(
							ngramsCondProbFile,
							Constants.TAB_CHAR + entry.getValue()[i], true);
					System.out
							.print("\n" + (++count) + Constants.TAB_CHAR
									+ "P(" + entry.getKey() + "|"
									+ Constants.ClassLabel.values()[i].name()
									+ ")" + Constants.TAB_CHAR
									+ entry.getValue()[i]);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

	public static HashMap<String, Double[]> readCondProbsOfNgramsFromFile(
			String filePath) {
		
		File ngramsCondProbFile = new File(filePath);
		// This will keep the conditional probabilities of each ngram for each
		// class: P(g|C_i)
		HashMap<String, Double[]> ngramsWithCondProbs = new HashMap<String, Double[]>();

		try {
			List<String> lines = FileUtils.readLines(ngramsCondProbFile);
			int lineNumber = 0;
			for (String line : lines) {
				lineNumber++;
				//Skip header line
				if (line != null && !line.equals("") && lineNumber!=1)
				{
					String [] tokens = line.split(Constants.TAB_CHAR);
					Double [] probs = new Double[tokens.length-1];
					for (int i=0;i<probs.length;i++)
						probs[i] = Double.valueOf(tokens[i+1]);
					ngramsWithCondProbs.put(tokens[0], probs);
				}		
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		return ngramsWithCondProbs;
	}

    public static HashMap<String, Double> getTopRankedNgrams(String filePath) throws IOException {
        HashMap<String, Double> topRankedNgrams = new HashMap<String, Double>();
        List<String> fileLines = FileUtils.readLines(new File(filePath));
        for (int i = 1; i <= Constants.NUMBER_OF_DATA_INPUT; i++) {
            String[] values = fileLines.get(i).split(Constants.TAB_CHAR);
            topRankedNgrams.put(values[1], Double.parseDouble(values[2]));
        }
        return topRankedNgrams;
    }

    public static void generateDistinctiveNgramsFiles(String dataPath, String extension, boolean isTestData) {
        HashMap<String, Short[]> ngrams = constructNgrams(dataPath, extension, isTestData);
        extractIGOfNgrams(ngrams, extension);
        extractEntropyOfNgrams(ngrams, extension);
        extractSalienceOfNgrams(ngrams, extension);
        if (extension.equals(Constants.CLASS_EXTENSION))
        	calculateCondProbsOfNgrams(ngrams);
    }

    public static String prepareWekaFileHeader(HashMap<String, Double> topRankedNgrams, String extension, boolean isTestData) throws IOException {
        //Data class label for reports and input files
        String trainOrTestLabel = isTestData ? Constants.TEST_LABEL : Constants.TRAIN_LABEL;

        //Generate data file and prepare it with its headers
        String wekaDataFilePath = (Constants.REPORTS_PATH
                + trainOrTestLabel
                + Constants.UNDERSCORE + extension
                + Constants.UNDERSCORE + "ngram"
                + Constants.UNDERSCORE + Constants.NGRAM_SIZE
                + Constants.UNDERSCORE + Constants.NUMBER_OF_DATA_INPUT
                + ".arff").toLowerCase();

        File wekaDataFile = new File(wekaDataFilePath);
        FileUtils.deleteQuietly(wekaDataFile);

        FileUtils.write(wekaDataFile, "%%%\n"
                + "% This " + trainOrTestLabel.toLowerCase() + " data file consists of the most distictive ngrams extracted\n"
                + "% from reversed engineered *." + extension + " files of known Android apps\n"
                + "% to classify unknown Anroid apps as " + Constants.CLASS_A_NAME.toLowerCase() + " or " + Constants.CLASS_B_NAME.toLowerCase() + " application\n"
                + "% by using Weka classifier algorithms. The study is being conducted\n"
                + "% by Munir Geden and Jens Krinke as part of a research in UCL.\n"
                + "%\n"
                + "@relation 'ngram'\n", true);

        FileUtils.write(wekaDataFile, "@attribute appname string\n", true);
        for (Map.Entry<String, Double> entry : topRankedNgrams.entrySet()) {
            FileUtils.write(wekaDataFile, "@attribute " + entry.getKey() + " numeric\n", true);
        }

        FileUtils.write(wekaDataFile, "@attribute class {" + Constants.CLASS_A_NAME + "," + Constants.CLASS_B_NAME + "}\n", true);
        FileUtils.write(wekaDataFile, "@data\n", true);
        return wekaDataFilePath;
    }
    public static void prepareWekaFileDataPerApp(HashMap<String, Double> topRankedNgrams, String appPath, String dataFilePath, String extension, boolean isTestData) {

        try {

            //Arff file that will keep training data values
            File dataFile = new File(dataFilePath);

            //Collect all files under the path of given app
            Collection<File> files = FileHandler.findFiles(appPath, new String[]{extension});

            //This will keep the calculated values of ngrams: log2(frequency) * information gain
            HashMap<String, Integer> calculatedData = new HashMap<String, Integer>();
            for (Map.Entry<String, Double> entry : topRankedNgrams.entrySet()) {
                calculatedData.put(entry.getKey(), 0);
            }

            //Retrieve class type, its name and its integer array index from file path
            boolean taxon = appPath.contains(File.separator + Constants.CLASS_A_NAME + File.separator);
            String className = taxon ? Constants.CLASS_A_NAME : Constants.CLASS_B_NAME;

            //Find appName from path
            String appName = appNameOfFile(appPath, extension);

            //Print iteration information for console
            System.out.print("Analysing app... Class:" + className + Constants.TAB_CHAR + "Extension:" + extension + Constants.TAB_CHAR + "App Name:" + appName + "\n");

            //Number of files traversed
            int fileIterator = -1;

            //Performance monitor watch
            StopWatch watch = new StopWatch();
            watch.reset();
            watch.start();

            //Traverse app files to be analyzed
            for (File file : files) {
                fileIterator++;

                //Read files as byte array and convert them to hexadecimal strings by eliminating zero bytes
                byte[] fileHex = FileHandler.readFileToByteArray(file.getAbsolutePath());
                for (int i = 0; i < fileHex.length - Constants.NGRAM_SIZE * 2; i++) {
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < Constants.NGRAM_SIZE; j++) {
                        //if (fileHex[i + j] != 0) 
                        sb.append(String.format("%02X", fileHex[i + j]));

                    }
                    String ngram = sb.toString();
                    if (topRankedNgrams.containsKey(ngram)) {
                        if (calculatedData.containsKey(ngram)) {
                            calculatedData.put(ngram, 1);
                        }
                    }
                }
            }

            watch.stop();
            //Print the time elapsed to analyze the app.
            System.out.print("Completed... Elapsed Time:" + (double) watch.getTime() / 1000.0 + " secs." + Constants.TAB_CHAR + "Number of Files:" + (fileIterator + 1) + "\n");

            //Append app inputs to arff file 
            FileUtils.write(dataFile, appName + ",", true);
            for (Map.Entry<String, Integer> entry : calculatedData.entrySet()) {
                FileUtils.write(dataFile, entry.getValue() + ",", true);
            }
            FileUtils.write(dataFile, className + "\n", true);

        } catch (Exception e) {
            e.printStackTrace();
        }

    }
    public static void prepareWekaFileData(String topRankedFeaturesFile, String dataPath, String extension, boolean isTestData) {
        try {
            HashMap<String, Double> topRankedNgrams = new HashMap<String, Double> ();
            topRankedNgrams = getTopRankedNgrams(topRankedFeaturesFile);
            String dataFilePath = prepareWekaFileHeader(topRankedNgrams, extension, isTestData);
            String[] appPaths = appPathsOfGivenClass(dataPath, extension, isTestData);
            for (String appPath : appPaths) {
                prepareWekaFileDataPerApp(topRankedNgrams, appPath, dataFilePath, extension, isTestData);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

  
    private static String[] appPathsOfGivenClass(String dataPath, String extension, boolean isTestData) {
        String dataTypeFolder = StringUtils.EMPTY;
        if (!(dataPath.contains(File.separator + Constants.TEST_LABEL + File.separator) || dataPath.contains(File.separator + Constants.TRAIN_LABEL + File.separator))) {
            dataTypeFolder = isTestData ? Constants.TEST_LABEL : Constants.TRAIN_LABEL;
        }
        String classPathA = dataPath + File.separator + dataTypeFolder + File.separator + Constants.CLASS_A_NAME + File.separator + extension.toUpperCase() + File.separator;
        String classPathB = dataPath + File.separator + dataTypeFolder + File.separator + Constants.CLASS_B_NAME + File.separator + extension.toUpperCase() + File.separator;
        String[] appPaths = ArrayUtils.addAll(FileHandler.findFolderContents(classPathA), FileHandler.findFolderContents(classPathB));
        return appPaths;
    }

    private static String appNameOfFile(String appPath, String extension) {
        //Retrieve app name from file path
        if (appPath.contains(Constants.UNDERSCORE + extension.toUpperCase())) {
            String[] folders = appPath.substring(0, appPath.lastIndexOf(Constants.UNDERSCORE + extension.toUpperCase())).split(File.separator);
            return folders[folders.length - 1];
        } else {
            String[] folders = appPath.split(File.separator);
            return folders[folders.length - 1];
        }

    }

    private static double[] minIndexAndValue(NGramIGPair[] arr) {
		double minValue = Double.MAX_VALUE;
		int minIndex = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getValue() < minValue) {
				minValue = arr[i].getValue();
				minIndex = i;
			}
		}
		return new double[] { (double) minIndex, minValue };
	}

	private static double[] maxIndexAndValue(NGramIGPair[] arr) {
		double maxValue = 0.0;
		int maxIndex = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getValue() > maxValue) {
				maxValue = arr[i].getValue();
				maxIndex = i;
			}
		}
		return new double[] { (double) maxIndex, maxValue };
	}

    private static int randWithinRange(int min, int max) {
        Random rand = new Random();
        int numValue = rand.nextInt((max - min) + 1) + min;
        return numValue;
    }

}

class NGramIGPair implements Comparable<NGramIGPair> {

    private String key;
    private double value;

    public NGramIGPair(String key, double value) {
        this.key = key;
        this.value = value;
    }

    /**
     * @return the key
     */
    public String getKey() {
        return key;
    }

    /**
     * @param key the key to set
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     * @return the value
     */
    public double getValue() {
        return value;
    }

    /**
     * @param value the value to set
     */
    public void setValue(double value) {
        this.value = value;
    }

    @Override
    public int compareTo(NGramIGPair item) {
        if (this.value < item.value) {
            return 1;
        } else if (this.value > item.value) {
            return -1;
        } else {
            return 0;
        }
    }
}