/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.io.File;
import java.sql.Timestamp;
import java.util.Date;

import weka.core.Instances;
import weka.core.converters.ConverterUtils.DataSource;
import weka.classifiers.Evaluation;
import weka.classifiers.meta.FilteredClassifier;
import weka.classifiers.trees.J48;
import weka.classifiers.trees.RandomForest;
import weka.classifiers.bayes.NaiveBayes;
import weka.classifiers.bayes.NaiveBayesMultinomial;
import weka.classifiers.lazy.IBk;
import weka.classifiers.functions.SMO;
import weka.filters.unsupervised.attribute.Remove;

import org.apache.commons.io.FileUtils;

/**
 *
 * @author msgeden
 */
public class WekaClassifier {

	public static void getClassifierResultsForAllNgrams(String featureType) {
		try {

			
			
			String extension = FileHandler
					.readConfigValue(Constants.FILE_EXTENSION_CONFIG);
			
			String resultTablePath = FileHandler
					.readConfigValue(Constants.REPORTS_PATH_CONFIG)
					+ extension + Constants.UNDERSCORE + "weka_total.tsv";
			File results = new File(resultTablePath);
			
			String[] inputSizes = FileHandler
					.readConfigValue(Constants.NUMBER_OF_DATA_INPUT_CONFIG).split(",");
			
			for (int i=0;i<4;i++)
			{
				FileUtils.write(results, "\nExtension\tExtraction\tFeature\tTimestamp",true);
				FileUtils.write(results, "\n"+ extension + "\t" + Constants.EXTRACTION_LABELS[i] + "\t"+featureType+ "\t" + new Timestamp(new Date().getTime()),true);
				FileUtils.write(results, "\nInput Size\tMNB\t\tNB\t\tKNN("+ FileHandler
						.readConfigValue(Constants.KNN_KVALUE_CONFIG)+")\t\tJ48\t\tRF\t\tSVM",true);
				for (String inputSize : inputSizes)
				{
					FileUtils.write(results, "\n"+ inputSize, true);
					String trainingDataPath =  FileHandler
							.readConfigValue(Constants.REPORTS_PATH_CONFIG) + "train" + Constants.UNDERSCORE + 
							extension + Constants.UNDERSCORE 
							+ featureType + Constants.UNDERSCORE + inputSize + Constants.UNDERSCORE + i + ".arff";
					
					String testDataPath =  FileHandler
							.readConfigValue(Constants.REPORTS_PATH_CONFIG) + "test" + Constants.UNDERSCORE + 
							extension + Constants.UNDERSCORE 
							+  featureType + Constants.UNDERSCORE + inputSize + Constants.UNDERSCORE + i + ".arff";
				
					String[] mnb = getClassifierResults(trainingDataPath, testDataPath, extension,
							"mnb");
					FileUtils.write(results, "\t"+ mnb[0]+"%\t"+mnb[1], true);
					
					String[] nb = getClassifierResults(trainingDataPath, testDataPath, extension,
							"nb");
					FileUtils.write(results, "\t"+ nb[0]+"%\t"+nb[1], true);
					
					String[] knn = getClassifierResults(trainingDataPath, testDataPath, extension,
							"knn");
					FileUtils.write(results, "\t"+ knn[0]+"%\t"+knn[1], true);
					
					String[] j48 = getClassifierResults(trainingDataPath, testDataPath, extension,
							"j48");
					FileUtils.write(results, "\t"+ j48[0]+"%\t"+j48[1], true);
		
					String[] rf = getClassifierResults(trainingDataPath, testDataPath, extension,
							"rf");
					FileUtils.write(results, "\t"+ rf[0]+"%\t"+rf[1], true);
		
					String[] svm = getClassifierResults(trainingDataPath, testDataPath, extension,
							"svm");
					FileUtils.write(results, "\t"+ svm[0]+"%\t"+svm[1], true);
				}
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	public static String[] getClassifierResults(String trainingDataPath,
			String testDataPath, String extension, String algorithm) {
		String [] response = 	new String[]{"",""};
		
		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			if (algorithm.equals("all")) {
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"mnb");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"nb");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"knn");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"j48");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"rf");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"svm");
				
			} else {

				String resultsPath = (FileHandler
						.readConfigValue(Constants.REPORTS_PATH_CONFIG)
						+ "weka"
						+ Constants.UNDERSCORE
						+ algorithm
						+ Constants.UNDERSCORE
						+ extension
						+ Constants.UNDERSCORE + ngramSize + "-grams" + ".log")
						.toLowerCase();

				File resultsFile = new File(resultsPath);
				//FileUtils.deleteQuietly(resultsFile);

				// Training Instances
				DataSource trainingSource = new DataSource(trainingDataPath);
				Instances trainingData = trainingSource.getDataSet();
				if (trainingData.classIndex() == -1) {
					trainingData
							.setClassIndex(trainingData.numAttributes() - 1);
				}

				// Test Instances
				DataSource testSource = new DataSource(testDataPath);
				Instances testData = testSource.getDataSet();
				if (testData.classIndex() == -1) {
					testData.setClassIndex(testData.numAttributes() - 1);
				}

				Remove rm = new Remove();
				//rm.setAttributeIndices("1"); // remove 1st attribute since it is
												// id
				FilteredClassifier fc = new FilteredClassifier();
				fc.setFilter(rm);
				if (algorithm.equals("j48")) {
					J48 j48 = new J48();
					j48.setUnpruned(true);
					fc.setClassifier(j48);
				} else if (algorithm.equals("nb")) {
					NaiveBayes nb = new NaiveBayes();
					fc.setClassifier(nb);
				} else if (algorithm.equals("mnb")) {
					NaiveBayesMultinomial nb = new NaiveBayesMultinomial();
					fc.setClassifier(nb);
				} else if (algorithm.equals("knn")) {
					IBk ibk = new IBk();
					ibk.setKNN(Integer.parseInt(FileHandler
							.readConfigValue((Constants.KNN_KVALUE_CONFIG))));
					fc.setClassifier(ibk);
				}
				else if (algorithm.equals("rf")) {
					RandomForest rf = new RandomForest();
					fc.setClassifier(rf);
				}
				else if (algorithm.equals("svm")) {
					SMO svm = new SMO();
					fc.setClassifier(svm);
				}
				// train and make predictions
				fc.buildClassifier(trainingData);

				// evaluate classifier and print some statistics
				// String[] evalOptions = new String[2];
				// evalOptions[0] = "-t";
				// evalOptions[1] = "/some/where/somefile.arff";

				Evaluation eval = new Evaluation(trainingData);
				eval.evaluateModel(fc, testData);
				response[0]=Double.toString(eval.pctCorrect());
				response[1]=Double.toString(eval.areaUnderROC(1));
				System.out.println(eval.toSummaryString(
						"\nSummary Results: "+algorithm.toUpperCase()+"\n============\n" , false));
				System.out
						.println(eval
								.toClassDetailsString("\nClass Details\n============\n"));
				System.out.println(eval
						.toMatrixString("\nMatrix Results\n============\n"));
				System.out.println("\nApps\n======\n");

				FileUtils.write(resultsFile, eval.toSummaryString(
						"\nSummary Results\n============\n\n", false), true);
				FileUtils
						.write(resultsFile,
								eval.toClassDetailsString("\nClass Details\n============\n"),
								true);
				FileUtils
						.write(resultsFile,
								eval.toMatrixString("\nMatrix Results\n============\n"),
								true);
//				FileUtils.write(resultsFile, "\nApps\n======\n", true);
//
//				for (int i = 0; i < testData.numInstances(); i++) {
//					double pred = fc.classifyInstance(testData.instance(i));
//					System.out.print("Name: "
//							+ testData.instance(i).stringValue(0));
//					FileUtils.write(resultsFile, "Name: "
//							+ testData.instance(i).stringValue(0), true);
//					System.out.print(", Actual: "
//							+ testData.classAttribute().value(
//									(int) testData.instance(i).classValue()));
//					FileUtils.write(
//							resultsFile,
//							", Actual: "
//									+ testData.classAttribute().value(
//											(int) testData.instance(i)
//													.classValue()), true);
//					System.out.println(", Predicted: "
//							+ testData.classAttribute().value((int) pred));
//					FileUtils.write(resultsFile, ", Predicted: "
//							+ testData.classAttribute().value((int) pred)
//							+ "\n", true);
//				}
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		return response;
	}
}
