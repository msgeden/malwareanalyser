/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.io.File;

import weka.core.Instances;
import weka.core.converters.ConverterUtils.DataSource;
import weka.classifiers.Evaluation;
import weka.classifiers.meta.FilteredClassifier;
import weka.classifiers.trees.J48;
import weka.classifiers.bayes.NaiveBayes;
import weka.classifiers.bayes.NaiveBayesMultinomial;
import weka.classifiers.lazy.IBk;
import weka.classifiers.functions.SMO;
import weka.filters.unsupervised.attribute.Remove;

import org.apache.commons.io.FileUtils;

/**
 *
 * @author msgeden
 */
public class WekaClassifier {

	public static void getClassifierResults(String trainingDataPath,
			String testDataPath, String extension, String algorithm) {
		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			if (algorithm.equals("all")) {
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"j48");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"nb");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"mnb");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"knn");
				getClassifierResults(trainingDataPath, testDataPath, extension,
						"svm");
				return;
			} else {

				String resultsPath = (FileHandler
						.readConfigValue(Constants.REPORTS_PATH_CONFIG)
						+ "weka"
						+ Constants.UNDERSCORE
						+ algorithm
						+ Constants.UNDERSCORE
						+ extension
						+ Constants.UNDERSCORE + ngramSize + "-grams" + ".log")
						.toLowerCase();

				File resultsFile = new File(resultsPath);
				FileUtils.deleteQuietly(resultsFile);

				// Training Instances
				DataSource trainingSource = new DataSource(trainingDataPath);
				Instances trainingData = trainingSource.getDataSet();
				if (trainingData.classIndex() == -1) {
					trainingData
							.setClassIndex(trainingData.numAttributes() - 1);
				}

				// Test Instances
				DataSource testSource = new DataSource(testDataPath);
				Instances testData = testSource.getDataSet();
				if (testData.classIndex() == -1) {
					testData.setClassIndex(testData.numAttributes() - 1);
				}

				Remove rm = new Remove();
				//rm.setAttributeIndices("1"); // remove 1st attribute since it is
												// id
				FilteredClassifier fc = new FilteredClassifier();
				fc.setFilter(rm);
				if (algorithm.equals("j48")) {
					J48 j48 = new J48();
					j48.setUnpruned(true);
					fc.setClassifier(j48);
				} else if (algorithm.equals("nb")) {
					NaiveBayes nb = new NaiveBayes();
					fc.setClassifier(nb);
				} else if (algorithm.equals("mnb")) {
					NaiveBayesMultinomial nb = new NaiveBayesMultinomial();
					fc.setClassifier(nb);
				} else if (algorithm.equals("knn")) {
					IBk ibk = new IBk();
					ibk.setKNN(Integer.parseInt(FileHandler
							.readConfigValue((Constants.KNN_KVALUE_CONFIG))));
					fc.setClassifier(ibk);
				} else if (algorithm.equals("svm")) {
					SMO svm = new SMO();
					fc.setClassifier(svm);
				}
				// train and make predictions
				fc.buildClassifier(trainingData);

				// evaluate classifier and print some statistics
				// String[] evalOptions = new String[2];
				// evalOptions[0] = "-t";
				// evalOptions[1] = "/some/where/somefile.arff";

				Evaluation eval = new Evaluation(trainingData);
				eval.evaluateModel(fc, testData);
				System.out.println(eval.toSummaryString(
						"\nSummary Results\n============\n", false));
				System.out
						.println(eval
								.toClassDetailsString("\nClass Details\n============\n"));
				System.out.println(eval
						.toMatrixString("\nMatrix Results\n============\n"));
				System.out.println("\nApps\n======\n");

				FileUtils.write(resultsFile, eval.toSummaryString(
						"\nSummary Results\n============\n\n", false), true);
				FileUtils
						.write(resultsFile,
								eval.toClassDetailsString("\nClass Details\n============\n"),
								true);
				FileUtils
						.write(resultsFile,
								eval.toMatrixString("\nMatrix Results\n============\n"),
								true);
				FileUtils.write(resultsFile, "\nApps\n======\n", true);

				for (int i = 0; i < testData.numInstances(); i++) {
					double pred = fc.classifyInstance(testData.instance(i));
					System.out.print("Name: "
							+ testData.instance(i).stringValue(0));
					FileUtils.write(resultsFile, "Name: "
							+ testData.instance(i).stringValue(0), true);
					System.out.print(", Actual: "
							+ testData.classAttribute().value(
									(int) testData.instance(i).classValue()));
					FileUtils.write(
							resultsFile,
							", Actual: "
									+ testData.classAttribute().value(
											(int) testData.instance(i)
													.classValue()), true);
					System.out.println(", Predicted: "
							+ testData.classAttribute().value((int) pred));
					FileUtils.write(resultsFile, ", Predicted: "
							+ testData.classAttribute().value((int) pred)
							+ "\n", true);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
