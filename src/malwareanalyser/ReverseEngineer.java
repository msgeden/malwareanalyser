/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.io.*;
import java.util.*;

import com.google.common.io.Files;
import com.juliasoft.amalia.apk.ApkReader;
import com.juliasoft.amalia.dex.file.DexFile;
import com.juliasoft.amalia.dex.file.DexReader;

import java.util.concurrent.TimeUnit;

import org.apache.bcel.classfile.ClassParser;
import org.apache.bcel.classfile.Constant;
import org.apache.bcel.classfile.ConstantPool;
import org.apache.bcel.classfile.JavaClass;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;

/**
 *
 * @author msgeden
 */
public class ReverseEngineer {

	public static void extractApkFile(String filePath, String extension) {
		if (extension.equals(Constants.DEX_EXTENSION))
			extractApkFileAsDex(filePath);
		else if (extension.equals(Constants.SMALI_EXTENSION))
			extractApkFileAsSmali(filePath);
		else if (extension.equals(Constants.CLASS_EXTENSION))
			extractApkFileAsClass(filePath);
		else if (extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION)) {
			File file = new File(filePath);
			extractAllClassFilesAsBerc(file.getParent() + File.separator
					+ Constants.BERTILLONAGE_CLASS_EXTENSION.toUpperCase()
					+ File.separator + file.getName() + Constants.UNDERSCORE
					+ Constants.BERTILLONAGE_CLASS_EXTENSION.toUpperCase()
					+ File.separator);
		} else if (extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION))
			extractApkFileAsBerd(filePath);
		else if (extension.equals(Constants.PERM_EXTENSION))
			extractSmaliFolderAsPerm(filePath);
		else if (extension.equals(Constants.MANF_EXTENSION))
			extractSmaliFolderAsManf(filePath);
	}

	public static void extractAllApkFiles(String filePath, String extension)
			throws IOException {
		if (extension.equals(Constants.DEX_EXTENSION))
			extractAllApkFilesAsDex(filePath);
		else if (extension.equals(Constants.SMALI_EXTENSION))
			extractAllApkFilesAsSmali(filePath);
		else if (extension.equals(Constants.CLASS_EXTENSION))
			extractAllApkFilesAsClass(filePath);
		else if (extension.equals(Constants.BERTILLONAGE_CLASS_EXTENSION))
			extractAllClassFilesAsBerc(filePath);
		else if (extension.equals(Constants.CLASS_CONSTANT_POOL_EXTENSION))
			extractAllClassesAsConstantPool(filePath);
		else if (extension.equals(Constants.CLASS_OPCODE_EXTENSION))
			extractAllClassesAsOpcodes(filePath);
		else if (extension.equals(Constants.BERTILLONAGE_DEX_EXTENSION))
			extractAllApkFilesAsBerd(filePath);
		else if (extension.equals(Constants.PERM_EXTENSION))
			extractAllSmaliFoldersAsPerm(filePath);
		else if (extension.equals(Constants.MANF_EXTENSION))
			extractAllSmaliFoldersAsManf(filePath);
	}

	public static void extractApkFileAsBerd(String filePath) {
		File file = new File(filePath);
		String newFilePath = file.getParent()
				+ File.separator
				+ Constants.BERTILLONAGE_DEX_EXTENSION.toUpperCase()
				+ File.separator
				+ file.getName().replace(
						"." + Constants.APK_EXTENSION,
						"_"
								+ Constants.BERTILLONAGE_DEX_EXTENSION
										.toUpperCase())
				+ File.separator
				+ file.getName().replace("." + Constants.APK_EXTENSION,
						"." + Constants.BERTILLONAGE_DEX_EXTENSION);
		File berFile = new File(newFilePath);
		ApkReader apkReader;
		try {
			apkReader = new ApkReader(file);
			byte[] dexFileBytes = apkReader.extractDex();
			DexReader dexReader = new DexReader(true, true, dexFileBytes);
			DexFile dexFile = dexReader.readDex();
			DexSignatureBuilder visitor = new DexSignatureBuilder();
			dexFile.accept(visitor);
			FileUtils.write(berFile, visitor.getSignature(), false);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static void extractAllApkFilesAsBerd(String dirPath) {
		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.APK_EXTENSION });
		for (File file : files) {
			extractApkFileAsBerd(file.getAbsolutePath());
		}
	}

	public static void extractApkFileAsDex(String filePath) {
		unzipFileWithExcludes(filePath, Constants.DEX_EXTENSION);
	}

	public static void extractAllApkFilesAsDex(String dirPath) {
		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.APK_EXTENSION });
		for (File file : files) {
			extractApkFileAsDex(file.getAbsolutePath());
		}
	}

	public static void extractApkFileAsSmali(String filePath) {
		try {
			apktoolDecompiler(filePath);
			String extractedDirStr = filePath.substring(0,
					filePath.lastIndexOf(Files.getFileExtension(filePath)) - 1);
			String newDirStr = FileHandler.createDirectory(new File(
					extractedDirStr).getParent() + File.separator,
					Constants.SMALI_EXTENSION.toUpperCase());
			File dir = new File(extractedDirStr);
			File newDir = new File(newDirStr + File.separator
					+ Files.getNameWithoutExtension(filePath)
					+ Constants.UNDERSCORE
					+ Constants.SMALI_EXTENSION.toUpperCase());
			if (dir.isDirectory()) {
				dir.renameTo(newDir);
			}
			FileUtils.deleteDirectory(new File(newDir + File.separator
					+ "assets"));
			FileUtils
					.deleteDirectory(new File(newDir + File.separator + "res"));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void extractAllApkFilesAsSmali(String dirPath)
			throws IOException {
		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.APK_EXTENSION });
		for (File file : files) {
			extractApkFileAsSmali(file.getAbsolutePath());
		}
	}

	public static void extractApkFileAsClass(String filePath) {
		dex2jarExecuter(filePath);
		String jarPath = filePath.substring(0,
				filePath.lastIndexOf(File.separator) + 1)
				+ Files.getNameWithoutExtension(filePath)
				+ Constants.EXTENSION_SEPERATOR + Constants.JAR_EXTENSION;
		unzipFile(jarPath, Constants.CLASS_EXTENSION.toUpperCase());
		FileUtils.deleteQuietly(new File(jarPath));
	}

	public static void extractAllApkFilesAsClass(String dirPath) {
		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.APK_EXTENSION });
		for (File file : files) {
			extractApkFileAsClass(file.getAbsolutePath());
		}
	}

	public static void extractClassFileAsBerc(String filePath) {
		File file = new File(filePath);
		ClassParser parser;
		try {
			parser = new ClassParser(filePath);
			JavaClass clazz = parser.parse();
			StringBuilder sb = new StringBuilder();
			sb.append("C:    " + clazz.toString().split("\n")[0]);
			org.apache.bcel.classfile.Field[] fields = clazz.getFields();
			if (fields.length > 0) {
				// Arrays.sort(fields);
				for (int i = 0; i < fields.length; i++) {
					sb.append("\n\tF:    " + fields[i].toString());

				}
			}
			org.apache.bcel.classfile.Method[] methods = clazz.getMethods();
			if (methods.length > 0) {
				// Arrays.sort(methods);
				for (int i = 0; i < methods.length; i++) {
					sb.append("\n\tM:    " + methods[i].toString());
				}
			}
			String md5 = new String(DigestUtils.md5Hex(sb.toString()));
			String signature = sb.toString() + "\nH:    " + md5;
			String newFilePath = file.getParent()
					+ File.separator
					+ file.getName().replace("." + Constants.CLASS_EXTENSION,
							"." + Constants.BERTILLONAGE_CLASS_EXTENSION);
			File berFile = new File(newFilePath.replace(
					File.separator + Constants.CLASS_EXTENSION.toUpperCase()
							+ File.separator,
					File.separator
							+ Constants.BERTILLONAGE_CLASS_EXTENSION
									.toUpperCase() + File.separator).replace(
					Constants.UNDERSCORE
							+ Constants.CLASS_EXTENSION.toUpperCase()
							+ File.separator,
					Constants.UNDERSCORE
							+ Constants.BERTILLONAGE_CLASS_EXTENSION
									.toUpperCase() + File.separator));
			// File berFile = new File(newFilePath);
			FileUtils.write(berFile, signature, false);

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		// JavaClass clazz = Repository.lookupClass("java.lang.String");

	}

	public static void extractAllClassesAsOpcodes(String dirPath) {

		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.CLASS_EXTENSION });
		for (File file : files) {
			extractClassAsOpcodes(file.getAbsolutePath());
		}
	}

	public static void extractClassAsOpcodes(String filePath) {
		File file = new File(filePath);
		StringBuilder opcSb = new StringBuilder();
		ClassParser parser;
		try {
			parser = new ClassParser(filePath);
			JavaClass clazz = parser.parse();
			org.apache.bcel.classfile.Method[] methods = clazz.getMethods();
			if (methods.length > 0) {
				// Arrays.sort(methods);
				for (int i = 0; i < methods.length; i++) {
					org.apache.bcel.classfile.Code code = methods[i].getCode();
					if (code != null) {
						byte[] bytes = code.getCode();
						String[] opCodesIndexes = code.toString().split("\n");
						ArrayList<Byte> opcodes = new ArrayList<Byte>();
						for (int j = 1; j < opCodesIndexes.length; j++) {
							String index = opCodesIndexes[j].split(":")[0];
							if (index.matches("[0-9]+"))
								opcodes.add(bytes[Integer
										.parseInt(opCodesIndexes[j].split(":")[0])]);
						}
						Byte[] opcodeBytes = opcodes.toArray(new Byte[opcodes
								.size()]);
						opcSb.append(new String(ArrayUtils
								.toPrimitive(opcodeBytes)));
					}
				}
			}
			String newOpcFilePath = file.getParent()
					+ File.separator
					+ file.getName().replace("." + Constants.CLASS_EXTENSION,
							"." + Constants.CLASS_OPCODE_EXTENSION);
			File opcFile = new File(newOpcFilePath.replace(
					File.separator + Constants.CLASS_EXTENSION.toUpperCase()
							+ File.separator,
					File.separator
							+ Constants.CLASS_OPCODE_EXTENSION.toUpperCase()
							+ File.separator).replace(
					Constants.UNDERSCORE
							+ Constants.CLASS_EXTENSION.toUpperCase()
							+ File.separator,
					Constants.UNDERSCORE
							+ Constants.CLASS_OPCODE_EXTENSION.toUpperCase()
							+ File.separator));
			FileUtils.write(opcFile, opcSb.toString(), false);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("\nPath:" + filePath);
		}
	}

	public static void extractAllClassesAsConstantPool(String dirPath) {

		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.CLASS_EXTENSION });
		for (File file : files) {
			extractClassAsConstantPool(file.getAbsolutePath());
		}
	}

	public static void extractClassAsConstantPool(String filePath) {
		File file = new File(filePath);
		StringBuilder cpSb = new StringBuilder();
		ClassParser parser;
		try {
			parser = new ClassParser(filePath);
			JavaClass clazz = parser.parse();
			ConstantPool cp = clazz.getConstantPool();
			org.apache.bcel.classfile.Method[] methods = clazz.getMethods();
			Constant[] cps = cp.getConstantPool();
			for (int i = 0; i < methods.length; i++) {
				if (cps[i] != null) {
					String cpsi = cps[i].toString();
					cpsi = cpsi.substring(cpsi.indexOf("(") + 1,
							cpsi.indexOf(")"));
					cpSb.append(cpsi + "\n");
				}
			}
			String newCpFilePath = file.getParent()
					+ File.separator
					+ file.getName().replace("." + Constants.CLASS_EXTENSION,
							"." + Constants.CLASS_CONSTANT_POOL_EXTENSION);
			File cpFile = new File(newCpFilePath.replace(
					File.separator + Constants.CLASS_EXTENSION.toUpperCase()
							+ File.separator,
					File.separator
							+ Constants.CLASS_CONSTANT_POOL_EXTENSION
									.toUpperCase() + File.separator).replace(
					Constants.UNDERSCORE
							+ Constants.CLASS_EXTENSION.toUpperCase()
							+ File.separator,
					Constants.UNDERSCORE
							+ Constants.CLASS_CONSTANT_POOL_EXTENSION
									.toUpperCase() + File.separator));
			FileUtils.write(cpFile, cpSb.toString(), false);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("\nPath:" + filePath);
		}
	}

	public static void extractAllClassFilesAsBerc(String dirPath) {
		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.CLASS_EXTENSION });
		for (File file : files) {
			extractClassFileAsBerc(file.getAbsolutePath());
		}
	}

	public static void extractAllSmaliFoldersAsPerm(String dirPath) {

		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.XML_EXTENSION });
		for (File file : files) {
			if (!file.getAbsolutePath().endsWith(
					"/original/AndroidManifest.xml")
					&& file.getAbsolutePath().contains(
							Constants.UNDERSCORE
									+ Constants.SMALI_EXTENSION.toUpperCase())
					&& file.getAbsolutePath().contains(
							Constants.PERMISSION_MANIFEST_FILE))
				extractSmaliFolderAsPerm(file.getAbsolutePath());
		}
	}

	public static void extractSmaliFolderAsPerm(String filePath) {
		File file = new File(filePath);
		try {
			String permFilePath = file
					.getParent()
					.replace(
							File.separator
									+ Constants.SMALI_EXTENSION.toUpperCase()
									+ File.separator,
							File.separator
									+ Constants.PERM_EXTENSION.toUpperCase()
									+ File.separator)
					.replace(
							Constants.UNDERSCORE
									+ Constants.SMALI_EXTENSION.toUpperCase(),
							Constants.UNDERSCORE
									+ Constants.PERM_EXTENSION.toUpperCase())
					+ File.separator
					+ file.getName().replace("." + Constants.XML_EXTENSION,
							"." + Constants.PERM_EXTENSION);
			File permFile = new File(permFilePath);
			FileUtils.write(permFile, FileHandler.readFileToString(filePath),
					false);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("\nPath:" + filePath);
		}
	}

	public static void extractAllSmaliFoldersAsManf(String dirPath) {

		Collection<File> files = FileHandler.findFiles(dirPath,
				new String[] { Constants.MF_EXTENSION.toUpperCase() });
		for (File file : files) {
			if (file.getAbsolutePath().contains(
					Constants.UNDERSCORE
							+ Constants.SMALI_EXTENSION.toUpperCase())
					&& file.getAbsolutePath().contains(Constants.MANIFEST_FILE))

				extractSmaliFolderAsManf(file.getAbsolutePath());
		}
	}

	public static void extractSmaliFolderAsManf(String filePath) {
		File file = new File(filePath);
		try {
			String manfFilePath = file
					.getParent()
					.replace(
							File.separator
									+ Constants.SMALI_EXTENSION.toUpperCase()
									+ File.separator,
							File.separator
									+ Constants.MANF_EXTENSION.toUpperCase()
									+ File.separator)
					.replace(
							Constants.UNDERSCORE
									+ Constants.SMALI_EXTENSION.toUpperCase()
									+ File.separator + "original"
									+ File.separator + "META-INF",
							Constants.UNDERSCORE
									+ Constants.MANF_EXTENSION.toUpperCase())
					+ File.separator
					+ file.getName()
							.replace(".MF", "." + Constants.MANF_EXTENSION)
							.toLowerCase();
			File manfFile = new File(manfFilePath);
			FileUtils.write(manfFile, FileHandler.readFileToString(filePath),
					false);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("\nPath:" + filePath);
		}
	}

	private static void unzipFile(String filePath, String folderPostFix) {
		String fileExtension = Files.getFileExtension(filePath);
		if (!Arrays
				.asList(new String[] { Constants.JAR_EXTENSION,
						Constants.APK_EXTENSION }).contains(
						fileExtension.toLowerCase())) {
			return;
		}
		String fileDirPath = filePath.substring(0,
				filePath.lastIndexOf(File.separator) + 1);
		String destinationFolder = Files.getNameWithoutExtension(filePath)
				+ Constants.UNDERSCORE + folderPostFix.toUpperCase();
		String destinationPath = FileHandler.createDirectory(fileDirPath,
				folderPostFix.toUpperCase() + File.separator
						+ destinationFolder);
		ProcessBuilder pb = new ProcessBuilder("unzip", filePath, "-d",
				destinationPath);
		pb.directory(new File(fileDirPath));
		try {
			Process p = pb.start();
			LogStreamReader lsr = new LogStreamReader(p.getInputStream());
			Thread thread = new Thread(lsr, "LogStreamReader");
			thread.start();
			p.waitFor(Constants.PROCESS_TIMEOUT_SECS, TimeUnit.SECONDS);
			p.destroy();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void unzipFileWithExcludes(String filePath,
			String folderPostFix) {
		String fileExtension = Files.getFileExtension(filePath);
		if (!Arrays
				.asList(new String[] { Constants.JAR_EXTENSION,
						Constants.APK_EXTENSION }).contains(
						fileExtension.toLowerCase())) {
			return;
		}
		String fileDirPath = filePath.substring(0,
				filePath.lastIndexOf(File.separator) + 1);
		String destinationFolder = Files.getNameWithoutExtension(filePath)
				+ Constants.UNDERSCORE + folderPostFix.toUpperCase();
		String destinationPath = FileHandler.createDirectory(fileDirPath,
				folderPostFix.toUpperCase() + File.separator
						+ destinationFolder);
		ProcessBuilder pb = new ProcessBuilder("unzip", filePath, "-d",
				destinationPath, "-x", "res/*", "-x", "assets/*");
		pb.directory(new File(fileDirPath));
		try {
			Process p = pb.start();
			LogStreamReader lsr = new LogStreamReader(p.getInputStream());
			Thread thread = new Thread(lsr, "LogStreamReader");
			thread.start();
			p.waitFor(Constants.PROCESS_TIMEOUT_SECS, TimeUnit.SECONDS);
			p.destroy();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void apktoolDecompiler(String filePath) {
		String fileExtension = Files.getFileExtension(filePath);
		String fileName = Files.getNameWithoutExtension(filePath);
		if (!Arrays.asList(new String[] { Constants.APK_EXTENSION }).contains(
				fileExtension.toLowerCase())) {
			return;
		}
		String fileDirPath = filePath.substring(0,
				filePath.lastIndexOf(File.separator) + 1);
		ProcessBuilder pb = new ProcessBuilder("java", "-jar",
				FileHandler.readConfigValue(Constants.APKTOOL_PATH_CONFIG),
				"d", fileName + "." + fileExtension);
		pb.directory(new File(fileDirPath));
		try {
			Process p = pb.start();
			LogStreamReader lsr = new LogStreamReader(p.getInputStream());
			Thread thread = new Thread(lsr, "LogStreamReader");
			thread.start();
			p.waitFor(Constants.PROCESS_TIMEOUT_SECS, TimeUnit.SECONDS);
			p.destroy();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void dex2jarExecuter(String apkFilePath) {
		String fileExtension = Files.getFileExtension(apkFilePath);
		if (!Arrays.asList(new String[] { Constants.APK_EXTENSION }).contains(
				fileExtension.toLowerCase())) {
			return;
		}
		String fileDirPath = apkFilePath.substring(0,
				apkFilePath.lastIndexOf(File.separator) + 1);
		String jarPath = fileDirPath
				+ Files.getNameWithoutExtension(apkFilePath) + "."
				+ Constants.JAR_EXTENSION;
		ProcessBuilder pb = new ProcessBuilder(
				FileHandler.readConfigValue(Constants.DEX2JAR_PATH_CONFIG),
				"-f", "-o", jarPath, apkFilePath);
		pb.directory(new File(fileDirPath));
		try {
			Process p = pb.start();
			LogStreamReader lsr = new LogStreamReader(p.getInputStream());
			Thread thread = new Thread(lsr, "LogStreamReader");
			thread.start();
			p.waitFor(Constants.PROCESS_TIMEOUT_SECS, TimeUnit.SECONDS);
			p.destroy();
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Could not extract apk file with dex2jar tool:"
					+ apkFilePath);
		}
		System.out.println("Successfully extracted apk file with dex2jar tool:"
				+ apkFilePath);
	}
}

class LogStreamReader implements Runnable {

	private BufferedReader reader;

	public LogStreamReader(InputStream is) {
		this.reader = new BufferedReader(new InputStreamReader(is));
	}

	public void run() {
		try {
			String line = reader.readLine();
			while (line != null) {
				System.out.println(line);
				line = reader.readLine();
			}
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
