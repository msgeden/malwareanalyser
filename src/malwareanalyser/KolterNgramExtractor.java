/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package malwareanalyser;

import java.util.*;
import java.io.File;
import java.io.IOException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.StopWatch;

/**
 *
 * @author msgeden
 */
public class KolterNgramExtractor {

    public static HashMap<String, Short[]> ngramConstructorPerApp(HashMap<String, Short[]> cumulativeNgrams, String appPath, String extension, boolean isTestData, File reportFile) {

        try {
            //Collect all files under the path of given app
            Collection<File> files = FileHandler.findFiles(appPath, new String[]{extension});

            //This will keep the information whether given app owns ngrams
            HashSet<String> ngrams = new HashSet();

            //Retrieve class type, its name and its integer array index from file path
            boolean taxon = appPath.contains(File.separator + Constants.CLASS_A_NAME + File.separator);
            String className = taxon ? Constants.CLASS_A_NAME : Constants.CLASS_B_NAME;
            int classFrequencyIndex = taxon ? 0 : 1;

            //Retrieve app name from file path
            String[] folders = appPath.split(File.separator);
            String appName = folders[folders.length - 1];

            //Number of files traversed
            int fileIterator = -1;

            //Performance monitor watch
            StopWatch watch = new StopWatch();
            watch.reset();
            watch.start();

            //Traverse app files to be analyzed
            for (File file : files) {
                fileIterator++;

                //Read files as byte array and convert them to hexadecimal strings by eliminating zero bytes
                byte[] fileHex = FileHandler.readFileToByteArray(file.getAbsolutePath());
                for (int i = 0; i < fileHex.length - Constants.KOLTER_NGRAM_SIZE * 2; i++) {
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < Constants.KOLTER_NGRAM_SIZE; j++) {
                        //if (fileHex[i + j] != 0) 
                        sb.append(String.format("%02X", fileHex[i + j]));

                    }
                    String ngram = sb.toString();
                    ngrams.add(ngram);
                }
            }
            //Merge app ngram set with cumulative ngram hashmap
            for (String ngram : ngrams) {
                if (cumulativeNgrams.containsKey(ngram)) {
                    Short[] classFrequencies = cumulativeNgrams.get(ngram);
                    classFrequencies[classFrequencyIndex] = (short) (classFrequencies[classFrequencyIndex] + 1);
                    cumulativeNgrams.put(ngram, classFrequencies);
                } else {
                    Short[] classFrequencies = new Short[]{0, 0};
                    classFrequencies[classFrequencyIndex] = 1;
                    cumulativeNgrams.put(ngram, classFrequencies);
                }
            }

            //These values are stored in ngrams hashmap not to iterate once more during the information gain calculation
            if (cumulativeNgrams.containsKey(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES)) {
                Short[] appCountsForClasses = cumulativeNgrams.get(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);
                appCountsForClasses[classFrequencyIndex] = (short) (appCountsForClasses[classFrequencyIndex] + 1);
                cumulativeNgrams.put(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES, appCountsForClasses);
            } else {
                Short[] appCountsForClasses = new Short[]{0, 0};
                appCountsForClasses[classFrequencyIndex] = 1;
                cumulativeNgrams.put(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES, appCountsForClasses);
            }

            //Print the number of unique ngrams, files are processed.
            //Print the number of unique ngrams, files are processed.
            FileUtils.write(reportFile, className
                    + Constants.TAB_CHAR + extension
                    + Constants.TAB_CHAR + ngrams.size()
                    + Constants.TAB_CHAR + cumulativeNgrams.size()
                    + Constants.TAB_CHAR + (fileIterator + 1)
                    + Constants.TAB_CHAR + (double) watch.getTime() / 1000.0
                    + Constants.TAB_CHAR + appName
                    + "\n", true);
            System.out.print(className
                    + Constants.TAB_CHAR + extension
                    + Constants.TAB_CHAR + ngrams.size()
                    + Constants.TAB_CHAR + cumulativeNgrams.size()
                    + Constants.TAB_CHAR + (fileIterator + 1)
                    + Constants.TAB_CHAR + (double) watch.getTime() / 1000.0
                    + Constants.TAB_CHAR + appName
                    + "\n");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return cumulativeNgrams;
    }

    public static String ngramIGExtractor(HashMap<String, Short[]> ngrams, String extension) {

        //Top-ranked ngram features file name generation
        String randomNgramsPath = (FileHandler.readConfigValue(Constants.REPORTS_PATH)
                + extension
                + Constants.UNDERSCORE + "random_ngrams"
                + Constants.UNDERSCORE + Constants.KOLTER_NGRAM_SIZE
                + ".tsv").toLowerCase();
        File randomNgramsFile = new File(randomNgramsPath);

        String rankedNgramsPath = (FileHandler.readConfigValue(Constants.REPORTS_PATH)
                + extension
                + Constants.UNDERSCORE + "topranked_ngrams"
                + Constants.UNDERSCORE + Constants.KOLTER_NGRAM_SIZE
                + ".tsv").toLowerCase();
        File rankedNgramsFile = new File(rankedNgramsPath);
        StopWatch watch = new StopWatch();
        watch.reset();
        watch.start();

        //Try to delete if it exists without exception
        FileUtils.deleteQuietly(randomNgramsFile);
        FileUtils.deleteQuietly(rankedNgramsFile);

        try {

            //This will keep the information gain extracted from each ngram
            HashMap<String, Double> ngramsWithIG = new HashMap();

            //This structure will keep the top-ranked ngrams with their information gain
            NGramIGPair[] topRankedNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];
            //This structure is defined to validate the distribution of information gain scores
            NGramIGPair[] randomNgrams = new NGramIGPair[Constants.TOP_RANKED_SIZE];

            //Retrieve the number of apps per class from the specific entry
            Short[] countApps = ngrams.get(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);
            double totalNumberOfAppsInClassA = (double) countApps[0];//10
            double totalNumberOfAppsInClassB = (double) countApps[1];//10
            double totalNumberOfApps = (double) (totalNumberOfAppsInClassA + totalNumberOfAppsInClassB);

            //Remove this specific entry not to interpret as ngram
            ngrams.remove(Constants.TOTAL_COUNT_OF_APPS_FOR_CLASSES);

            //Iterate ngram hashmap to calculate information gain for each ngram
            for (Map.Entry<String, Short[]> entry : ngrams.entrySet()) {

                //Calculate the number of apps for each classes that owns the given ngram
                Short[] values = entry.getValue();

                //Terms that are needed for information gain calculation
                double numberOfAppsHoldNgramInClassA = (double) values[0];
                double numberOfAppsDoNotHoldNgramInClassA = (double) (totalNumberOfAppsInClassA - values[0]);
                double numberOfAppsHoldNgramInClassB = (double) values[1];
                double numberOfAppsDoNotHoldNgramInClassB = (double) (totalNumberOfAppsInClassB - values[1]);

                //Calculation formula of information gain: For details see the paper of Kolter et. al and Reddy et. al.
                double[] informationGainForNgram = new double[4];
                informationGainForNgram[0] = (numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
                        * Math.log((numberOfAppsHoldNgramInClassA / totalNumberOfAppsInClassA)
                                / (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                informationGainForNgram[1] = (numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
                        * Math.log((numberOfAppsDoNotHoldNgramInClassA / totalNumberOfAppsInClassA)
                                / (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                informationGainForNgram[2] = (numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
                        * Math.log((numberOfAppsHoldNgramInClassB / totalNumberOfAppsInClassB)
                                / (((numberOfAppsHoldNgramInClassA + numberOfAppsHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                informationGainForNgram[3] = (numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
                        * Math.log((numberOfAppsDoNotHoldNgramInClassB / totalNumberOfAppsInClassB)
                                / (((numberOfAppsDoNotHoldNgramInClassA + numberOfAppsDoNotHoldNgramInClassB) / totalNumberOfApps) * 0.5));

                //Skip infinite and NaN terms
                double informationGainForNgramTotal = 0.0;
                for (int i = 0; i < informationGainForNgram.length; i++) {
                    if (!(Double.isNaN(informationGainForNgram[i]) || !Double.isFinite(informationGainForNgram[i]))) {
                        informationGainForNgramTotal += informationGainForNgram[i];
                    }
                }
                //Add calculated information gain for the given ngram
                ngramsWithIG.put(entry.getKey(), informationGainForNgramTotal);
            }

            //Initialize top-ranked array values for ordering and comparison
            for (int i = 0; i < topRankedNgrams.length; i++) {
                topRankedNgrams[i] = new NGramIGPair(Integer.toString(i), 0.0);
            }

            for (Map.Entry<String, Double> entry : ngramsWithIG.entrySet()) {

                //Find the first minimum value and its index in top-ranked array to replace-> index0:index of the item, index 1-> value of item
                double[] minIG = minIndexAndValue(topRankedNgrams);
                if (entry.getValue() > minIG[1]) {
                    topRankedNgrams[(int) minIG[0]] = new NGramIGPair(entry.getKey(), entry.getValue());
                }

                //If there is positive number add this value to the array with random index to validate distribution
                if (entry.getValue() > 0.0) {
                    randomNgrams[randWithinRange(0, Constants.TOP_RANKED_SIZE - 1)] = new NGramIGPair(entry.getKey(), entry.getValue());
                }
            }
            //Sort top ranked array and print it to file and console
            Arrays.sort(topRankedNgrams);
            FileUtils.write(rankedNgramsFile, "Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n");
            for (int i = 0; i < topRankedNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n");
                FileUtils.write(rankedNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + topRankedNgrams[i].getKey()
                        + Constants.TAB_CHAR + topRankedNgrams[i].getValue()
                        + "\n", true);
            }
            //Print random array to file and console without sorting
            FileUtils.write(randomNgramsFile, "Line"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n", true);
            System.out.print("Rank"
                    + Constants.TAB_CHAR + "Ngram"
                    + Constants.TAB_CHAR + "Information Gain"
                    + "\n");

            for (int i = 0; i < randomNgrams.length; i++) {
                System.out.print((i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n");
                FileUtils.write(randomNgramsFile, (i + 1)
                        + Constants.TAB_CHAR + randomNgrams[i].getKey()
                        + Constants.TAB_CHAR + randomNgrams[i].getValue()
                        + "\n", true);
            }
            watch.stop();
            //Print the time elapsed to analyze the app.
            System.out.println("Analysing Information Gains... Elapsed Time:" + (double) watch.getTime() / 1000.0 + " secs." + "\n");

        } catch (Exception e) {
            e.printStackTrace();
        }
        return rankedNgramsFile.getAbsolutePath();
    }

    public static HashMap<String, Double> topRankedNgrams(String filePath) throws IOException {
        HashMap<String, Double> topRankedNgrams = new HashMap();
        List<String> fileLines = FileUtils.readLines(new File(filePath));
        for (int i = 1; i <= Constants.NUMBER_OF_DATA_INPUT; i++) {
            String[] values = fileLines.get(i).split(Constants.TAB_CHAR);
            topRankedNgrams.put(values[1], Double.parseDouble(values[2]));
        }
        return topRankedNgrams;
    }

    public static void wekaDataConstructorPerApp(HashMap<String, Double> topRankedNgrams, String appPath, String dataFilePath, String extension, boolean isTestData) {

        try {

            //Arff file that will keep training data values
            File dataFile = new File(dataFilePath);

            //Collect all files under the path of given app
            Collection<File> files = FileHandler.findFiles(appPath, new String[]{extension});

            //This will keep the calculated values of ngrams: log2(frequency) * information gain
            HashMap<String, Integer> calculatedData = new HashMap();
            for (Map.Entry<String, Double> entry : topRankedNgrams.entrySet()) {
                calculatedData.put(entry.getKey(), 0);
            }

            //Retrieve class type, its name and its integer array index from file path
            boolean taxon = appPath.contains(File.separator + Constants.CLASS_A_NAME + File.separator);
            String className = taxon ? Constants.CLASS_A_NAME : Constants.CLASS_B_NAME;

            //Find appName from path
            String appName = appNameOfFile(appPath, extension);

            //Print iteration information for console
            System.out.print("Analysing app... Class:" + className + Constants.TAB_CHAR + "Extension:" + extension + Constants.TAB_CHAR + "App Name:" + appName + "\n");

            //Number of files traversed
            int fileIterator = -1;

            //Performance monitor watch
            StopWatch watch = new StopWatch();
            watch.reset();
            watch.start();

            //Traverse app files to be analyzed
            for (File file : files) {
                fileIterator++;

                //Read files as byte array and convert them to hexadecimal strings by eliminating zero bytes
                byte[] fileHex = FileHandler.readFileToByteArray(file.getAbsolutePath());
                for (int i = 0; i < fileHex.length - Constants.KOLTER_NGRAM_SIZE * 2; i++) {
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < Constants.KOLTER_NGRAM_SIZE; j++) {
                        //if (fileHex[i + j] != 0) 
                        sb.append(String.format("%02X", fileHex[i + j]));

                    }
                    String ngram = sb.toString();
                    if (topRankedNgrams.containsKey(ngram)) {
                        if (calculatedData.containsKey(ngram)) {
                            calculatedData.put(ngram, 1);
                        }
                    }
                }
            }

            watch.stop();
            //Print the time elapsed to analyze the app.
            System.out.print("Completed... Elapsed Time:" + (double) watch.getTime() / 1000.0 + " secs." + Constants.TAB_CHAR + "Number of Files:" + (fileIterator + 1) + "\n");

            //Append app inputs to arff file 
            FileUtils.write(dataFile, appName + ",", true);
            for (Map.Entry<String, Integer> entry : calculatedData.entrySet()) {
                FileUtils.write(dataFile, entry.getValue() + ",", true);
            }
            FileUtils.write(dataFile, className + "\n", true);

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public static void main(String[] args) throws IOException {

    }

    public static HashMap<String, Short[]> ngramConstructor(String dataPath, String extension, boolean isTestData) {

        HashMap<String, Short[]> ngrams = new HashMap();
        try {
            String[] appPaths = appPathsOfGivenClass(dataPath, extension, isTestData);

            //Data class label for reports and input files
            String trainOrTestLabel = isTestData ? Constants.TEST_LABEL : Constants.TRAIN_LABEL;

            //Generate report file name
            String reportFilePath = (FileHandler.readConfigValue(Constants.REPORTS_PATH)
                    + trainOrTestLabel
                    + Constants.UNDERSCORE + extension
                    + Constants.UNDERSCORE + "ngram"
                    + Constants.UNDERSCORE + Constants.KOLTER_NGRAM_SIZE
                    + Constants.UNDERSCORE + "report.tsv").toLowerCase();

            File reportFile = new File(reportFilePath);

            FileUtils.write(reportFile, "Class"
                    + Constants.TAB_CHAR + "Extension"
                    + Constants.TAB_CHAR + "# of Ngrams"
                    + Constants.TAB_CHAR + "# of Total Ngrams"
                    + Constants.TAB_CHAR + "Number of Files"
                    + Constants.TAB_CHAR + "Time Elapsed"
                    + Constants.TAB_CHAR + "App Name"
                    + Constants.TAB_CHAR + "\n", true);
            System.out.print("Number"
                    + Constants.TAB_CHAR + "Class"
                    + Constants.TAB_CHAR + "Extension"
                    + Constants.TAB_CHAR + "# of Ngrams"
                    + Constants.TAB_CHAR + "# of Total Ngrams"
                    + Constants.TAB_CHAR + "Number of Files"
                    + Constants.TAB_CHAR + "Time Elapsed"
                    + Constants.TAB_CHAR + "App Name"
                    + Constants.TAB_CHAR + "\n");
            int count = 0;
            for (String appPath : appPaths) {
                System.out.print((++count) + Constants.TAB_CHAR);
                ngrams = ngramConstructorPerApp(ngrams, appPath, extension, isTestData, reportFile);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ngrams;
    }

    public static String prepareDataFileHeader(HashMap<String, Double> topRankedNgrams, String extension, boolean isTestData) throws IOException {
        //Data class label for reports and input files
        String trainOrTestLabel = isTestData ? Constants.TEST_LABEL : Constants.TRAIN_LABEL;

        //Generate data file and prepare it with its headers
        String wekaDataFilePath = (FileHandler.readConfigValue(Constants.REPORTS_PATH)
                + trainOrTestLabel
                + Constants.UNDERSCORE + extension
                + Constants.UNDERSCORE + "ngram"
                + Constants.UNDERSCORE + Constants.KOLTER_NGRAM_SIZE
                + ".arff").toLowerCase();

        File wekaDataFile = new File(wekaDataFilePath);
        FileUtils.deleteQuietly(wekaDataFile);

        FileUtils.write(wekaDataFile, "%%%\n"
                + "% This " + trainOrTestLabel.toLowerCase() + " data file consists of the most distictive ngrams extracted\n"
                + "% from reversed engineered *." + extension + " files of known Android apps\n"
                + "% to classify unknown Anroid apps as " + Constants.CLASS_A_NAME.toLowerCase() + " or " + Constants.CLASS_B_NAME.toLowerCase() + " application\n"
                + "% by using Weka classifier algorithms. The study is being conducted\n"
                + "% by Munir Geden and Jens Krinke as part of a research in UCL.\n"
                + "%\n"
                + "@relation 'ngram'\n", true);

        FileUtils.write(wekaDataFile, "@attribute appname string\n", true);
        for (Map.Entry<String, Double> entry : topRankedNgrams.entrySet()) {
            FileUtils.write(wekaDataFile, "@attribute " + entry.getKey() + " numeric\n", true);
        }

        FileUtils.write(wekaDataFile, "@attribute class {" + Constants.CLASS_A_NAME + "," + Constants.CLASS_B_NAME + "}\n", true);
        FileUtils.write(wekaDataFile, "@data\n", true);
        return wekaDataFilePath;
    }

    public static void wekaDataConstructorForApps(String topRankedFeaturesFile, String dataPath, String extension, boolean isTestData) {
        try {
            HashMap<String, Double> topRankedNgrams = new HashMap();
            topRankedNgrams = topRankedNgrams(topRankedFeaturesFile);
            String dataFilePath = prepareDataFileHeader(topRankedNgrams, extension, isTestData);
            String[] appPaths = appPathsOfGivenClass(dataPath, extension, isTestData);
            for (String appPath : appPaths) {
                wekaDataConstructorPerApp(topRankedNgrams, appPath, dataFilePath, extension, isTestData);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public static void buildTopRankedNGramsFile(String dataPath, String extension, boolean isTestData) {
        HashMap<String, Short[]> ngrams = ngramConstructor(dataPath, extension, isTestData);
        ngramIGExtractor(ngrams, extension);
    }

    public static void buildTrainingDataFile(String topRankedNgramsFile, String dataPath, String extension, boolean isTestData) {
        wekaDataConstructorForApps(topRankedNgramsFile, dataPath, extension, isTestData);
    }

    private static String[] appPathsOfGivenClass(String dataPath, String extension, boolean isTestData) {
        String dataTypeFolder = StringUtils.EMPTY;
        if (!(dataPath.contains(File.separator + Constants.TEST_LABEL + File.separator) || dataPath.contains(File.separator + Constants.TRAIN_LABEL + File.separator))) {
            dataTypeFolder = isTestData ? Constants.TEST_LABEL : Constants.TRAIN_LABEL;
        }
        String classPathA = dataPath + File.separator + dataTypeFolder + File.separator + Constants.CLASS_A_NAME + File.separator + extension.toUpperCase() + File.separator;
        String classPathB = dataPath + File.separator + dataTypeFolder + File.separator + Constants.CLASS_B_NAME + File.separator + extension.toUpperCase() + File.separator;
        String[] appPaths = ArrayUtils.addAll(FileHandler.findFolderContents(classPathA), FileHandler.findFolderContents(classPathB));
        return appPaths;
    }

    private static String appNameOfFile(String appPath, String extension) {
        //Retrieve app name from file path
        if (appPath.contains(Constants.UNDERSCORE + extension.toUpperCase())) {
            String[] folders = appPath.substring(0, appPath.lastIndexOf(Constants.UNDERSCORE + extension.toUpperCase())).split(File.separator);
            return folders[folders.length - 1];
        } else {
            String[] folders = appPath.split(File.separator);
            return folders[folders.length - 1];
        }

    }

    private static double[] minIndexAndValue(NGramIGPair[] arr) {
        double minValue = Double.MAX_VALUE;
        int minIndex = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i].getValue() < minValue) {
                minValue = arr[i].getValue();
                minIndex = i;
            }
        }
        return new double[]{(double) minIndex, minValue};
    }

    private static int randWithinRange(int min, int max) {
        Random rand = new Random();
        int numValue = rand.nextInt((max - min) + 1) + min;
        return numValue;
    }

}

class NGramIGPair implements Comparable<NGramIGPair> {

    private String key;
    private double value;

    public NGramIGPair(String key, double value) {
        this.key = key;
        this.value = value;
    }

    /**
     * @return the key
     */
    public String getKey() {
        return key;
    }

    /**
     * @param key the key to set
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     * @return the value
     */
    public double getValue() {
        return value;
    }

    /**
     * @param value the value to set
     */
    public void setValue(double value) {
        this.value = value;
    }

    @Override
    public int compareTo(NGramIGPair item) {
        if (this.value < item.value) {
            return 1;
        } else if (this.value > item.value) {
            return -1;
        } else {
            return 0;
        }
    }
}