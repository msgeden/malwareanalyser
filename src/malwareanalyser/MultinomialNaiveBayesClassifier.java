/**
 * 
 */
package malwareanalyser;

import java.io.File;
import java.util.Collection;
import java.util.HashMap;

import malwareanalyser.Constants.ClassLabel;

import org.apache.commons.io.FileUtils;

/**
 * @author msgeden
 *
 */
public class MultinomialNaiveBayesClassifier {

	public static HashMap<String, Double[]> getClassifierResults(
			String condProbsPath, String dataPath, String extension,
			boolean isTestData) {

		HashMap<String, Double[]> appsClassProbs = new HashMap<String, Double[]>();
		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));
			HashMap<String, Double[]> condProbs = new HashMap<String, Double[]>();
			String[] appPaths = FileHandler.getAppPaths(dataPath, extension,
					isTestData);
			condProbs = NgramExtractor
					.readCondProbsOfNgramsFromFile(condProbsPath);

			appsClassProbs = calculateNgramLogProbsApps(appPaths, condProbs,
					extension, ngramSize);

			classifyApps(appPaths, appsClassProbs, extension);

		} catch (Exception e) {
			e.printStackTrace();
		}
		return appsClassProbs;
	}

	public static HashMap<String, Double[]> calculateNgramLogProbsApps(
			String[] appPaths, HashMap<String, Double[]> condProbs,
			String extension, int ngramSize) {

		// This structure will keep class probabilities for each App:
		// HashMap<AppId, Probability[Class]>
		HashMap<String, Double[]> appClassNgramProbs = new HashMap<String, Double[]>();
		try {
			double classDiffThreshold = Double.parseDouble(FileHandler
					.readConfigValue(Constants.CLASS_DIFF_THRESHOLD_CONFIG));

			Double[] priors = condProbs.get(Constants.PRIOR_PER_CLASS);
			int numberOfClass = priors.length;
			String ngramOfInterest = "";

			for (String appPath : appPaths) {
				// Collect all files under the path of given app
				Collection<File> files = FileHandler.findFiles(appPath,
						new String[] { extension });

				// Retrieve class type, its name and its integer array index
				// from
				// file path
				boolean taxon = appPath.contains(File.separator
						+ Constants.CLASS_A_NAME + File.separator);
				String className = taxon ? Constants.CLASS_A_NAME
						: Constants.CLASS_B_NAME;

				// Find appName from path
				String appName = FileHandler.getAppNameOfFile(appPath,
						extension);

				// Print iteration information for console
				System.out.print("Analysing app... Class:" + className
						+ Constants.TAB_CHAR + "Extension:" + extension
						+ Constants.TAB_CHAR + "App Name:" + appName + "\n");

				Double[] classProbabilities = new Double[numberOfClass];
				for (int i = 0; i < classProbabilities.length; i++)
					classProbabilities[i] = Double.MIN_VALUE;

				// Traverse app files to be analyzed
				for (File file : files) {

					// Read files as byte array and convert them to hexadecimal
					// strings
					byte[] fileHex = FileHandler.readFileToByteArray(file
							.getAbsolutePath());
					for (int i = 0; i < fileHex.length - (ngramSize - 1); i++) {
						StringBuilder sb = new StringBuilder();
						for (int j = 0; j < ngramSize; j++) {
							// if (fileHex[i + j] != 0)
							sb.append(String.format("%02X", fileHex[i + j]));

						}
						ngramOfInterest = sb.toString();
						Double[] condProbsOfNgram = condProbs
								.get(ngramOfInterest);
						if (condProbsOfNgram == null) {
							condProbsOfNgram = new Double[numberOfClass];
							for (int j = 0; j < numberOfClass; j++)
								condProbsOfNgram[j] = Double.MIN_VALUE;
						}
						double dif = Math
								.abs((condProbsOfNgram[0] - condProbsOfNgram[1])
										/ (condProbsOfNgram[0] + condProbsOfNgram[1]));
						if (dif > classDiffThreshold) {

							for (int j = 0; j < numberOfClass; j++) {
								classProbabilities[j] += Math
										.log(condProbsOfNgram[j]);
							}
						}
					}
				}
				for (int j = 0; j < numberOfClass; j++) {
					classProbabilities[j] += Math.log(priors[j]);
				}
				appClassNgramProbs.put(appName, classProbabilities);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		return appClassNgramProbs;
	}

	public static void classifyApps(String[] appPaths,
			HashMap<String, Double[]> appsClassProbs, String extension) {

		try {
			int ngramSize = Integer.parseInt(FileHandler
					.readConfigValue(Constants.NGRAM_SIZE_CONFIG));

			String resultsPath = FileHandler
					.readConfigValue(Constants.REPORTS_PATH_CONFIG)
					+ File.separator
					+ "multinomial_nb_results"
					+ Constants.UNDERSCORE
					+ "ngram"
					+ Constants.UNDERSCORE
					+ ngramSize + ".tsv";

			File resultsFile = new File(resultsPath);
			FileUtils.deleteQuietly(resultsFile);

			Constants.ClassLabel actualClassInfo = null;
			Constants.ClassLabel predictedClassInfo;
			int correctClassification = 0;
			int incorrectClassification = 0;
			int totalInstances = 0;
			// Traverse apps to be calculate class probabilities for each
			// app
			FileUtils.write(resultsFile,
					"\nResults\n======\n\nIncorrect Classifications:\n", true);
			System.out
					.print("\nResults\n======\n\nIncorrect Classifications:\n");
			for (String appPath : appPaths) {
				// Retrieve class type, its name and its integer array index
				// from file path
				boolean taxon = appPath.contains(File.separator
						+ Constants.CLASS_A_NAME + File.separator);

				// Find appName from path
				String appName = FileHandler.getAppNameOfFile(appPath,
						extension);

				actualClassInfo = taxon ? ClassLabel.Benign
						: ClassLabel.Malware;

				predictedClassInfo = predictAppClass(appsClassProbs
						.get(appName));
				// Count correct and incorrect classifications
				if (predictedClassInfo == actualClassInfo)
					correctClassification++;
				else {
					incorrectClassification++;
				}
				FileUtils.write(resultsFile,
						"\nApp Name: " + appName + Constants.TAB_CHAR
								+ "Actual: " + actualClassInfo.name()
								+ Constants.TAB_CHAR + "Predicted: "
								+ predictedClassInfo.name()
								+ Constants.TAB_CHAR, true);
				System.out.print("\nApp Name: " + appName + Constants.TAB_CHAR
						+ "Actual: " + actualClassInfo.name()
						+ Constants.TAB_CHAR + "Predicted: "
						+ predictedClassInfo.name());
			}
			totalInstances = correctClassification + incorrectClassification;
			double successRatio = (double) correctClassification
					/ totalInstances;
			FileUtils.write(resultsFile,
					"\nCorrectly Classified Instances  " + Constants.TAB_CHAR
							+ correctClassification + Constants.TAB_CHAR
							+ String.format("%.4f", (successRatio * 100))
							+ " %", true);
			FileUtils.write(resultsFile,
					"\nIncorrectly Classified Instances" + Constants.TAB_CHAR
							+ incorrectClassification + Constants.TAB_CHAR
							+ String.format("%.4f", ((1 - successRatio) * 100))
							+ " %", true);
			FileUtils.write(resultsFile, "\nTotal Number of Instances       "
					+ Constants.TAB_CHAR + totalInstances, true);
			System.out.print("\nCorrectly Classified Instances  "
					+ Constants.TAB_CHAR + correctClassification
					+ Constants.TAB_CHAR
					+ String.format("%.4f", (successRatio * 100)) + " %");
			System.out.print("\nIncorrectly Classified Instances"
					+ Constants.TAB_CHAR + incorrectClassification
					+ Constants.TAB_CHAR
					+ String.format("%.4f", ((1 - successRatio) * 100)) + " %");
			System.out.print("\nTotal Number of Instances       "
					+ Constants.TAB_CHAR + totalInstances);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static ClassLabel predictAppClass(Double[] classProbs) {
		double maxValue = Double.NEGATIVE_INFINITY;
		int maxIndex = 0;
		for (int i = 0; i < classProbs.length; i++) {
			if (classProbs[i] > maxValue) {
				maxValue = classProbs[i];
				maxIndex = i;
			}
		}
		return ClassLabel.values()[maxIndex];
	}

}
